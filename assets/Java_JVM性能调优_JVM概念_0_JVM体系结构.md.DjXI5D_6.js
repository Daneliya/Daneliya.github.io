import{_ as e,c as l,o as i,ah as s,aq as r,ar as t,as as o,at as c}from"./chunks/framework.D5cOWG0Y.js";const V=JSON.parse('{"title":"JVM体系结构","description":"","frontmatter":{"title":"JVM体系结构","date":"2023-11-20","tags":["JVM"],"categories":["JVM"]},"headers":[],"relativePath":"Java/JVM性能调优/JVM概念/0_JVM体系结构.md","filePath":"Java/JVM性能调优/JVM概念/0_JVM体系结构.md","lastUpdated":1755802517000}'),n={name:"Java/JVM性能调优/JVM概念/0_JVM体系结构.md"};function d(p,a,h,_,J,m){return i(),l("div",null,[...a[0]||(a[0]=[s('<h2 id="jvm体系结构" tabindex="-1">JVM体系结构 <a class="header-anchor" href="#jvm体系结构" aria-label="Permalink to “JVM体系结构”">​</a></h2><p><img src="'+r+'" alt="img" loading="lazy"></p><p>方法区和堆是所有线程共享的内存区域；</p><p>而java栈、本地方法栈和程序计数器是运行时数据区线程私有的内存区域。</p><p>垃圾回收，指的是堆内存的垃圾回收；方法区是特殊的堆，JVM调优99%是调堆（Heap）。</p><ol><li>Java堆（Heap）：是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内 存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实 例都在这里分配内存。</li><li>方法区（Method Area）：方法区（Method Area）与Java堆一样，是各个线程共享的内存区 域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数 据。</li><li>程序计数器（Program Counter Register）：程序计数器（Program Counter Register）是一块 较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li><li>JVM栈（JVM Stacks）：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是 线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方 法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态 链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机 栈中从入栈到出栈的过程。</li><li>本地方法栈（Native Method Stacks）：本地方法栈（Native Method Stacks）与虚拟机栈所发 挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服 务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li></ol><h2 id="类的生命周期" tabindex="-1">类的生命周期 <a class="header-anchor" href="#类的生命周期" aria-label="Permalink to “类的生命周期”">​</a></h2><p>类从被加载到虚拟机内存中开始，到GC卸载出内存为止，它的整个生命周期包括：</p><p><code>加载</code>、<code>连接</code>、<code>初始化</code>、<code>使用</code>和<code>卸载</code>，其中<strong>前三部是类的加载的过程</strong>，如下图；</p><p><img src="'+t+'" alt="687474703a2f2f737466165787437676c6106e67" loading="lazy"></p><ol><li>加载：查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象。</li><li>连接：连接又包含三块内容：验证、准备、初始化。 <ul><li>1）验证：文件格式、元数据、字节码、符号引用验证；</li><li>2）准备：为类的静态变量分配内存，并将其初始化为默认值；</li><li>3）解析：把类中的符号引用转换为直接引用。</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值。</li><li>使用：new出对象程序中使用。</li><li>卸载：执行垃圾回收。</li></ol><p>注意，加载、验证、准备、初始化、卸载这五个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。另外这7个阶段通常都是互相交叉的混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。</p><p><img src="'+o+'" alt="745698ec-c029-42a2-9203-3966b3a69f45" loading="lazy"></p><h2 id="jvm加载类的过程" tabindex="-1">JVM加载类的过程 <a class="header-anchor" href="#jvm加载类的过程" aria-label="Permalink to “JVM加载类的过程”">​</a></h2><p>JVM加载一个类的过程一般分为三个阶段：加载、连接和初始化。</p><p>JVM加载一个类时，首先通过类加载器找到类的字节码然后进行验证、准备和解析，最后执行类的静态代码块和静态变量的赋值操作。</p><p><img src="'+c+'" alt="JVM如何加载一个类" loading="lazy"></p><h3 id="一个类什么时候进入jvm" tabindex="-1">一个类什么时候进入JVM？ <a class="header-anchor" href="#一个类什么时候进入jvm" aria-label="Permalink to “一个类什么时候进入JVM？”">​</a></h3><ol><li>虚拟机启动时，执行main()方法的时候；</li><li>new对象的时候；</li><li>读取静态字段或静态方法的时候。</li></ol><h3 id="谁来负责将class文件加载到内存" tabindex="-1">谁来负责将Class文件加载到内存？ <a class="header-anchor" href="#谁来负责将class文件加载到内存" aria-label="Permalink to “谁来负责将Class文件加载到内存？”">​</a></h3><ol><li><strong>类装载器</strong>负责加载Class文件，Class文件在文件开头特定的文件标识（CA FE BA BE）；</li><li>类装载器只负责加载，是否可以允许由执行引擎（Execution Engine）决定。</li></ol><h3 id="class文件存在内存哪个位置" tabindex="-1">class文件存在内存哪个位置？ <a class="header-anchor" href="#class文件存在内存哪个位置" aria-label="Permalink to “class文件存在内存哪个位置？”">​</a></h3><p>类加载器从class文件抽取类信息放在<code>方法区</code>；</p><p>类信息包括：方法代码，变量名，方法名，访问权限，返回值等等。</p><h3 id="class对象存储在哪里" tabindex="-1">Class对象存储在哪里？ <a class="header-anchor" href="#class对象存储在哪里" aria-label="Permalink to “Class对象存储在哪里？”">​</a></h3><p><strong>堆</strong>。每当加载器从class文件加载一个类时都会加载类信息到方法区，同时生成class对象，Class对象new对象各对象实例。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to “参考资料”">​</a></h2><p><a href="https://www.yuque.com/u21195183/jvm" target="_blank" rel="noreferrer">JVM从入门到精通 (yuque.com)</a></p><p><a href="https://blog.csdn.net/weixin_50280576/article/details/113742011" target="_blank" rel="noreferrer">JVM 学习笔记（一）内存结构_codeali csdn jvm内存结构-CSDN博客</a></p>',29)])])}const g=e(n,[["render",d]]);export{V as __pageData,g as default};
