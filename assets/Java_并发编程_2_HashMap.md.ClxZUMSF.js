import{_ as i,c as a,o as n,aN as l}from"./chunks/framework.CMIDsdwV.js";const g=JSON.parse('{"title":"HashMap","description":"","frontmatter":{"title":"HashMap","permalink":"/java/concurrent/hashMap","tags":["HashMap"],"categories":["HashMap"]},"headers":[],"relativePath":"Java/并发编程/2_HashMap.md","filePath":"Java/并发编程/2_HashMap.md","lastUpdated":1767444225000}'),h={name:"Java/并发编程/2_HashMap.md"};function p(k,s,e,t,r,d){return n(),a("div",null,[...s[0]||(s[0]=[l(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /Java\\并发编程\\2_HashMap.md for this page in Markdown format</div><h1 id="hashmap" tabindex="-1">HashMap <a class="header-anchor" href="#hashmap" aria-label="Permalink to &quot;HashMap&quot;">​</a></h1><p>HashMap 作为 Java 中最常用的键值对存储容器，在 JDK8 中迎来了重大优化，核心围绕存储结构、插入规则、哈希算法和扩容机制展开，相比 JDK7 大幅提升了高并发场景下的性能和稳定性。</p><h2 id="一、核心差异总览" tabindex="-1">一、核心差异总览 <a class="header-anchor" href="#一、核心差异总览" aria-label="Permalink to &quot;一、核心差异总览&quot;">​</a></h2><table tabindex="0"><thead><tr><th>对比维度</th><th>JDK7 实现</th><th>JDK8 实现</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>链表插入方式</td><td>头插法（新节点放链表头部）</td><td>尾插法（新节点放链表尾部）</td></tr><tr><td>HASH 算法</td><td>复杂右移（4 次异或运算）</td><td>简化右移（仅 16 位高位异或）</td></tr><tr><td>扩容时机</td><td>插入节点前触发</td><td>插入节点后触发</td></tr><tr><td>扩容转移方式</td><td>逐个元素重新计算下标转移</td><td>按哈希高位批量分组转移（低位 + 高位）</td></tr><tr><td>潜在问题</td><td>多线程扩容可能导致死锁</td><td>解决死锁问题，性能更优</td></tr></tbody></table><h2 id="二、存储结构差异" tabindex="-1">二、存储结构差异 <a class="header-anchor" href="#二、存储结构差异" aria-label="Permalink to &quot;二、存储结构差异&quot;">​</a></h2><h3 id="_1-jdk7-数组-链表" tabindex="-1">1. JDK7：数组 + 链表 <a class="header-anchor" href="#_1-jdk7-数组-链表" aria-label="Permalink to &quot;1. JDK7：数组 + 链表&quot;">​</a></h3><p>JDK7 的 HashMap 仅由「数组（哈希桶）+ 链表」组成：</p><ul><li>数组：作为哈希表的主体，每个数组元素对应一个链表的头节点，用于快速定位哈希桶位置。</li><li>链表：用于解决哈希碰撞问题，当多个 key 计算出相同的数组下标时，会以链表形式存储在该哈希桶下。</li><li>缺陷：当链表过长时，查询效率会退化至 O (n)，大量哈希碰撞场景下性能较差。</li></ul><h3 id="_2-jdk8-数组-链表-红黑树" tabindex="-1">2. JDK8：数组 + 链表 + 红黑树 <a class="header-anchor" href="#_2-jdk8-数组-链表-红黑树" aria-label="Permalink to &quot;2. JDK8：数组 + 链表 + 红黑树&quot;">​</a></h3><p>JDK8 引入红黑树优化链表过长的问题，形成「数组 + 链表 + 红黑树」的混合结构：</p><ul><li>红黑树特性（平衡二叉树的一种）： <ol><li>调整规则比 AVL 树（完全平衡二叉树）宽松，插入 / 删除效率更高。</li><li>插入效率比链表低，但查询效率比链表高。查询效率为 O (logn)，介于链表（O (n)）和 AVL 树（O (logn)，调整成本更高）之间，是性能与效率的折中。</li><li>仅在链表长度达到阈值时触发转换，不影响少量数据的存储性能。</li></ol></li><li>核心阈值（JDK8 内置常量）： <ol><li><code>TREEIFY_THRESHOLD = 8</code>：当链表元素个数超过 8 时，链表自动转为红黑树。</li><li><code>UNTREEIFY_THRESHOLD = 6</code>：当红黑树节点个数小于 6 时，红黑树自动转回链表（避免少量节点时红黑树的调整成本高于查询收益）。</li></ol></li></ul><h2 id="三、核心操作实现差异" tabindex="-1">三、核心操作实现差异 <a class="header-anchor" href="#三、核心操作实现差异" aria-label="Permalink to &quot;三、核心操作实现差异&quot;">​</a></h2><p>在HashMap中，我们最常用的操作大概就是<code>put</code>与<code>get</code>了，来看看核心代码：</p><h3 id="_1-put-操作-插入键值对" tabindex="-1">1. Put 操作（插入键值对） <a class="header-anchor" href="#_1-put-操作-插入键值对" aria-label="Permalink to &quot;1. Put 操作（插入键值对）&quot;">​</a></h3><h4 id="jdk7-put-核心逻辑" tabindex="-1">JDK7 Put 核心逻辑 <a class="header-anchor" href="#jdk7-put-核心逻辑" aria-label="Permalink to &quot;JDK7 Put 核心逻辑&quot;">​</a></h4><p>JDK7 的 Put 操作流程简洁，核心分为 3 步，采用头插法插入节点：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 核心步骤伪代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 计算 key 的 hash 值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> indexFor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hash, table.length); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. 通过 indexFor 方法计算数组下标</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">table[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. 头插法：将 newNode 加入链表，新节点直接覆盖数组下标，原链表挂在新节点后</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>头插法原因：无需遍历链表，插入效率高。</li><li>缺陷：多线程扩容时，头插法会导致链表反转，可能引发死锁。</li><li>特殊处理：key 为 null 的元素固定存在数组第 0 个位置，且仅允许一个 null key。</li></ul><h4 id="jdk8-put-核心逻辑" tabindex="-1">JDK8 Put 核心逻辑 <a class="header-anchor" href="#jdk8-put-核心逻辑" aria-label="Permalink to &quot;JDK8 Put 核心逻辑&quot;">​</a></h4><p>jdk8中引入了红黑树，但并不是说链表并不存在，查阅源码，我们可以发现两个非常关键的值：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TREEIFT_THRESHOLD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UNTREEIFT_THRESHOLD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当链表的元素超过8时，会自动转成红黑树；当红黑树的节点数小于6时，变回链表。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> V </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">putVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash, K key, V value, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> onlyIfAbsent,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">               boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> evict) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Node&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;[] tab; Node&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; p; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n, i;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((tab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tab.length) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (tab </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> resize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()).length;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //当前插入的数组位置为空，可以直接插入</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tab[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        tab[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> newNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hash, key, value, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Node&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; e; K k;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //key相等情况，e在最后处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (p.hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ((k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k))))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //判断是红黑树的树节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((TreeNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K,V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)p).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">putTreeVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tab, hash, key, value);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //是链表结构 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">       else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> binCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; ; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">binCount) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//binCount是遍历链表过程中计数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //遍历链表，循环到尾结点，把新元素加在尾部，break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.next) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    p.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> newNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hash, key, value, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    //判断是否大于变成树的阈值-1,7会变成8，变成红黑树</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (binCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TREEIFY_THRESHOLD </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -1 for 1st</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                        treeifyBin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tab, hash);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //找到相等元素也break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e.hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    ((k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k))))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                p </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //重复key</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// existing mapping for key</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            V oldValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.value;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">onlyIfAbsent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                e.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            afterNodeAccess</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">modCount;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //扩容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> threshold)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        resize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    afterNodeInsertion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(evict);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><p>看完这段代码，我们就明白了为什么jdk8中使用的是尾插法。因为在判断是使用链表或红黑树的过程中，要判断是否超过8个元素，至少需要遍历一遍，所以使用尾插法，新元素可以直接插入在尾结点。</p><p>JDK8 的 Put 操作（<code>putVal</code> 方法）更严谨，采用尾插法插入节点，并支持红黑树插入：</p><ol><li>校验数组是否为空，为空则先扩容（<code>resize()</code>）。</li><li>根据 hash 值计算数组下标，若该位置为空，直接插入新节点。</li><li>若该位置已有节点，分 3 种情况处理： <ul><li>节点 key 与插入 key 相同：记录该节点，后续更新 value。</li><li>节点是红黑树节点（<code>TreeNode</code>）：调用红黑树插入方法（<code>putTreeVal</code>）。</li><li>节点是链表节点：遍历链表至尾部，用尾插法插入新节点；插入后判断链表长度是否超过 7（<code>TREEIFY_THRESHOLD - 1</code>），若是则转为红黑树（<code>treeifyBin</code>）。</li></ul></li><li>若存在重复 key，更新对应节点的 value 并返回旧值。</li><li>插入成功后，判断元素数量是否超过扩容阈值，若是则触发扩容。</li></ol><ul><li>尾插法原因：遍历链表计数（判断是否转红黑树）时，已遍历至尾部，尾插法无需额外开销，同时避免了多线程扩容的死锁问题。</li></ul><h3 id="_2-get-操作-查询键值对" tabindex="-1">2. Get 操作（查询键值对） <a class="header-anchor" href="#_2-get-操作-查询键值对" aria-label="Permalink to &quot;2. Get 操作（查询键值对）&quot;">​</a></h3><h4 id="jdk7-get-核心逻辑" tabindex="-1">JDK7 Get 核心逻辑 <a class="header-anchor" href="#jdk7-get-核心逻辑" aria-label="Permalink to &quot;JDK7 Get 核心逻辑&quot;">​</a></h4><p><code>get</code>操作就比较简单了，先找到数组的下标，再比较key是否和给定的key相同，不同则顺着链表找下一个，直到找到或为空。具体通过<code>getEntry()</code>方法，遍历比较hash值是否相等，比较key是否相等。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//key不为null,获取value</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K,V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getEntry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//判断链表中是否有值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         //链表中没值,也就是没有value</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       //链表中有值,获取key的hash值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Entry&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">V</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">indexFor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hash, table.length)];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             e </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.next) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Object k;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //判断key是否相同</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e.hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                ((k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.key) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">equals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k))))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//key相等,返回相应的value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">             }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//链表中没有相应的key</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>JDK7 的 Get 操作（<code>getEntry</code> 方法）流程简单，仅支持链表查询：</p><ol><li>校验数组是否为空，为空则直接返回 null。</li><li>计算 key 的 hash 值，通过 <code>indexFor</code> 方法获取数组下标。</li><li>遍历该下标对应的链表，依次比较节点 hash 值和 key（== 或 <code>equals</code>），匹配成功则返回节点，否则返回 null。</li></ol><ul><li>查询效率：链表长度越短，效率越高，最坏情况 O (n)。</li></ul><h4 id="jdk8-get-核心逻辑" tabindex="-1">JDK8 Get 核心逻辑 <a class="header-anchor" href="#jdk8-get-核心逻辑" aria-label="Permalink to &quot;JDK8 Get 核心逻辑&quot;">​</a></h4><p><code>get</code>方法大体思路不变，计算下标，然后遍历，只不过是比jdk7中多加上一个判断是否用链表存储还是红黑树存储的步骤：</p><ol><li>计算 key 的 hash 值和数组下标，定位到对应哈希桶。</li><li>若该位置节点直接匹配 key，返回节点。</li><li>若不匹配，判断节点类型： <ul><li>链表节点：遍历链表查询，O (n)。</li><li>红黑树节点：红黑树查找，O (logn)。</li></ul></li><li>未匹配到则返回 null。</li></ol><ul><li>优化点：红黑树大幅提升长链表场景下的查询效率。</li></ul><h3 id="_3-hash-算法差异" tabindex="-1">3. Hash 算法差异 <a class="header-anchor" href="#_3-hash-算法差异" aria-label="Permalink to &quot;3. Hash 算法差异&quot;">​</a></h3><h4 id="jdk7-hash-算法-复杂" tabindex="-1">JDK7 Hash 算法（复杂） <a class="header-anchor" href="#jdk7-hash-算法-复杂" aria-label="Permalink to &quot;JDK7 Hash 算法（复杂）&quot;">​</a></h4><p>JDK7 的 Hash 算法包含多次右移和异或运算，目的是让高位参与哈希计算，减少碰撞：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object k){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hashSeed;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 对 String 类型 key 做特殊哈希处理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sun.misc.Hashing.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringHash32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((String)k);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>关键：通过 4 次右移（20、12、7、4）和异或运算，将高位特征融入低位，减少哈希碰撞。</li></ul><p>在这当中，暂且不看hash种子，可以看到计算中存在大量的右移操作，那么为什么要进行右移呢，这是考虑到了碰撞性问题。之前提到使用<code>indexFor</code>来计算数组下标：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> indexFor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length){    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里提一点，HashMap的长度一定是一个二的次方数，这点是在它的初始化和扩容中被限定的。这里在计算下表时，一个二的次方数减去1，能够保证它的二进制数的后几位数字全部是1，便于计算下标。</p><p>举个例子，HashMap长度为16，这样计算出的hash值与0000 1111做与运算，只需要取后四位，就实现了数组下标的计算。而与操作的计算速度比取余操作是要快上一些的。</p><p>回到上面，继续讲为什么要进行大量的右移操作，还是以长度为16来看，如果几个key计算出的hash值为：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1010</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0110</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0010</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0110</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0000</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0110</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们发现，只要后四位一样，hash值都一样，碰撞性很高，所以这时要引入右移操作，让高位也能参与到与运算。让链表分散，减少链表长度。</p><h4 id="jdk8-hash-算法-简化" tabindex="-1">JDK8 Hash 算法（简化） <a class="header-anchor" href="#jdk8-hash-算法-简化" aria-label="Permalink to &quot;JDK8 Hash 算法（简化）&quot;">​</a></h4><p>JDK8 精简了 Hash 算法，仅保留 16 位高位右移异或，配合红黑树弥补性能损耗：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // key 为 null 时 hash 值为 0，否则将 hashCode 与高位 16 位异或</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hashCode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>简化原因：数组下标计算仅使用 hash 值的低位，将高位 16 位与低位异或，既保留高位特征，又简化计算。</li><li>配合优化：红黑树提升了哈希碰撞场景下的查询效率，无需依赖复杂哈希算法减少碰撞。</li></ul><h3 id="_4-数组下标计算" tabindex="-1">4. 数组下标计算 <a class="header-anchor" href="#_4-数组下标计算" aria-label="Permalink to &quot;4. 数组下标计算&quot;">​</a></h3><p>JDK7 和 JDK8 均使用 <code>h &amp; (length - 1)</code> 计算数组下标（替代取余运算，效率更高），前提是 HashMap 数组长度为 2 的幂次方（初始化和扩容时强制保证）：</p><ul><li>原理：2 的幂次方减 1 的二进制形式为「末尾全 1」（如 16-1=15，二进制 1111），与 hash 值做与运算时，仅保留 hash 值的低位，快速定位数组下标。</li><li>示例：hash 值为 1010 0110，数组长度 16（length-1=15，二进制 0000 1111），与运算结果为 0000 0110，对应数组下标 6。</li></ul><h2 id="四、扩容机制差异" tabindex="-1">四、扩容机制差异 <a class="header-anchor" href="#四、扩容机制差异" aria-label="Permalink to &quot;四、扩容机制差异&quot;">​</a></h2><p>扩容是 HashMap 的核心耗时操作，目的是增大数组容量，减少链表长度，提升查询效率。默认扩容因子（负载因子）为 0.75，即当元素数量达到数组容量的 75% 时，触发扩容，容量翻倍。</p><p>扩容是对数组进行扩容，而不是链表或红黑树。在初始化时数组的默认长度是16，前面提到当存储的元素很多时会发生hash碰撞。我们扩容的目的是将长链表的长度减短，提高查询效率。</p><p>由于扩容的源码比较长，就不贴在这里，只列出核心思想。</p><h3 id="_1-jdk7-扩容机制" tabindex="-1">1. JDK7 扩容机制 <a class="header-anchor" href="#_1-jdk7-扩容机制" aria-label="Permalink to &quot;1. JDK7 扩容机制&quot;">​</a></h3><p>只有当数量大于阈值，且当前插入位置不为空时才会进行扩容，并且容量为原先2倍。</p><p>在将老的table转移到新的table时，需要重新计算数组的下标。</p><p>扩容后，重新计算下标。以从16位扩容到32位为例：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">h</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      1010</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0110</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">31</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     0001</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1111</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">结果</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0000</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0110</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    （与之前相同）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">h</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">     1011</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0110</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">31</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    0001</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1111</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">结果</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  0001</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0110</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    （与之前不同，相当于比之前加了16）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>扩容后，数组下标可能改变，也可能不变。这时要看扩容的那一位的哈希值是1还是0，如果是1则不同，0则相同。但是在这个过程中，有可能造成死锁问题。</p><ul><li>扩容时机：元素插入前，当元素数量 &gt; 扩容阈值，且当前插入位置不为空时触发。</li><li>转移方式：逐个遍历旧数组元素，重新计算 hash 值和数组下标，将元素转移到新数组中（头插法）。</li><li>潜在问题：多线程下，头插法会导致链表反转，引发死锁；逐个转移效率较低。</li><li>下标变化：扩容后元素下标可能不变（hash 高位为 0）或变为「原下标 + 旧数组容量」（hash 高位为 1）。</li></ul><h3 id="_2-jdk8-扩容机制" tabindex="-1">2. JDK8 扩容机制 <a class="header-anchor" href="#_2-jdk8-扩容机制" aria-label="Permalink to &quot;2. JDK8 扩容机制&quot;">​</a></h3><p>JDK8扩容中，为了避免之前提到的死锁问题，改进了扩容方法。通过判断这1位是0还是1，是0则不变。如果是1 ，加上原先数组大小。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newTab[j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldCap] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hiHead;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//oldCap是原先的数组长度</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>扩容时机：元素插入后，当元素数量 &gt; 扩容阈值时触发（无需判断插入位置是否为空）。</li><li>转移方式：批量分组转移，无需重新计算 hash 值，仅通过 hash 高位判断元素归属： <ol><li>遍历旧数组链表 / 红黑树，按 hash 高位是否为 1，将元素分为「低位组」（下标不变）和「高位组」（下标 = 原下标 + 旧数组容量）。</li><li>分别将低位组和高位组批量转移到新数组的对应位置。</li></ol></li><li>优化点： <ol><li>批量转移效率高于逐个转移，无需重新计算 hash 值。</li><li>尾插法避免了多线程扩容的死锁问题。</li><li>红黑树转移时，直接按高位分组，无需重新构建红黑树（必要时拆分红黑树）。</li></ol></li></ul><h3 id="总结" tabindex="-1">总结： <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结：&quot;">​</a></h3><ul><li>扩容这一操作非常耗时，默认达到75%按照2倍进行扩容，这个75%也就是factor扩容因子。</li><li>JDK7中扩容是在节点还没有加到HashMap前发生的；JDK8中扩容是在节点加到HashMap后发生的。</li><li>JDK7扩容是一个一个元素计算然后转移，JDK8是先遍历，判断哪些是放到新数组的低位，哪些是高位，然后将low的元素和high的元素分别组合起来，一次性转移到新的数组中。</li></ul><h2 id="五、核心总结" tabindex="-1">五、核心总结 <a class="header-anchor" href="#五、核心总结" aria-label="Permalink to &quot;五、核心总结&quot;">​</a></h2><ol><li>存储结构：JDK8 引入红黑树，解决 JDK7 链表过长导致的查询性能退化问题，查询效率从 O (n) 优化至 O (logn)。</li><li>插入规则：JDK8 采用尾插法，解决 JDK7 头插法在多线程扩容时的死锁问题，同时配合链表计数逻辑，无额外性能损耗。</li><li>哈希算法：JDK8 简化哈希计算，通过红黑树弥补性能损耗，兼顾效率和简洁性。</li><li>扩容机制：JDK8 批量分组转移，无需重新计算 hash 值，效率更高，且解决了死锁问题。</li><li>性能优化：JDK8 HashMap 在高哈希碰撞、多线程（非并发安全，并发推荐 ConcurrentHashMap）场景下，性能和稳定性均优于 JDK7。</li><li>注意事项：扩容操作耗时较高，初始化 HashMap 时，建议根据预估元素数量指定初始容量，减少扩容次数。</li></ol><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><p><a href="https://trunks2008.github.io/concurrent/HashMap.html" target="_blank" rel="noreferrer">https://trunks2008.github.io/concurrent/HashMap.html</a></p><p><a href="https://www.cnblogs.com/javawxid/p/15644349.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/javawxid/p/15644349.html</a></p>`,81)])])}const y=i(h,[["render",p]]);export{g as __pageData,y as default};
