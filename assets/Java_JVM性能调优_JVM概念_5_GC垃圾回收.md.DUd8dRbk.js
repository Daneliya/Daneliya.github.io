import{_ as i,c as l,o as e,ah as r,aE as t,aF as s,aG as o,aH as n,aI as h,aJ as d}from"./chunks/framework.D5cOWG0Y.js";const G=JSON.parse('{"title":"GC垃圾回收","description":"","frontmatter":{"title":"GC垃圾回收","date":"2023-11-25","tags":["JVM"],"categories":["JVM"]},"headers":[],"relativePath":"Java/JVM性能调优/JVM概念/5_GC垃圾回收.md","filePath":"Java/JVM性能调优/JVM概念/5_GC垃圾回收.md","lastUpdated":1755802517000}'),c={name:"Java/JVM性能调优/JVM概念/5_GC垃圾回收.md"};function _(p,a,m,g,b,f){return e(),l("div",null,[...a[0]||(a[0]=[r('<h2 id="垃圾回收的区域" tabindex="-1">垃圾回收的区域 <a class="header-anchor" href="#垃圾回收的区域" aria-label="Permalink to “垃圾回收的区域”">​</a></h2><p><img src="'+t+'" alt="img" loading="lazy"></p><h2 id="gc之引用计数法" tabindex="-1">GC之引用计数法 <a class="header-anchor" href="#gc之引用计数法" aria-label="Permalink to “GC之引用计数法”">​</a></h2><p><img src="'+s+'" alt="img" loading="lazy"></p><h2 id="gc之复制算法" tabindex="-1">GC之复制算法 <a class="header-anchor" href="#gc之复制算法" aria-label="Permalink to “GC之复制算法”">​</a></h2><p><img src="'+o+'" alt="img" loading="lazy"><img src="'+n+'" alt="img" loading="lazy"></p><ul><li>好处：没有内存的碎片。</li><li>坏处：浪费了内存空间（多了一半空间to永远是空）。假设对象100%存活（极端情况），不适合使用复制算法。</li></ul><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to “使用场景”">​</a></h3><p>复制算法最佳使用场景：对象存活度较低的时候（新生区）</p><h2 id="gc之标记清除压缩算法" tabindex="-1">GC之标记清除压缩算法 <a class="header-anchor" href="#gc之标记清除压缩算法" aria-label="Permalink to “GC之标记清除压缩算法”">​</a></h2><h3 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to “标记清除”">​</a></h3><p><img src="'+h+'" alt="img" loading="lazy"></p><ul><li>优点：不需要额外的空间。</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片。</li></ul><h3 id="标记清除压缩" tabindex="-1">标记清除压缩 <a class="header-anchor" href="#标记清除压缩" aria-label="Permalink to “标记清除压缩”">​</a></h3><p><img src="'+d+'" alt="img" loading="lazy"></p><h3 id="标记清除压缩-改进" tabindex="-1">标记清除压缩（改进） <a class="header-anchor" href="#标记清除压缩-改进" aria-label="Permalink to “标记清除压缩（改进）”">​</a></h3><p>可以进行多次标记清除，再进行一次压缩。</p><h2 id="gc算法总结" tabindex="-1">GC算法总结 <a class="header-anchor" href="#gc算法总结" aria-label="Permalink to “GC算法总结”">​</a></h2><p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度） 内存整齐度：复制算法=标记压缩算法&gt;标记清除算法 内存利用率：标记压缩算法=标记清除算法&gt;复制算法</p><p>思考一个问题：难道没有最优算法吗？ 答案：没有，没有最好的算法，只有最合适的算法——》GC：分代收集算法</p><p>年轻代：</p><ul><li>存活率低</li><li>复制算法</li></ul><p>老年代：</p><ul><li>区域大：存活率高</li><li>标记清除（内存碎片不是太多）+标记压缩混合实现</li></ul>',24)])])}const u=i(c,[["render",_]]);export{G as __pageData,u as default};
