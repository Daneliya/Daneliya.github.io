import{_ as e,c as t,o as r,aN as o}from"./chunks/framework.CMIDsdwV.js";const i="/assets/Ff74D8svT0dnLCTI.BRlsw4_K.webp",l="/assets/V175yWyRWRI20B7K.A6zy1zBd.webp",m=JSON.parse('{"title":"分布式系统中的可观测性","description":"","frontmatter":{"title":"分布式系统中的可观测性","permalink":"/java/framework/distributed/observability","tags":["分布式监控"],"categories":["分布式监控"]},"headers":[],"relativePath":"Java/架构设计/分布式/06.分布式监控/0_可观测性.md","filePath":"Java/架构设计/分布式/06.分布式监控/0_可观测性.md","lastUpdated":1767444225000}'),n={name:"Java/架构设计/分布式/06.分布式监控/0_可观测性.md"};function p(s,a,h,d,c,u){return r(),t("div",null,[...a[0]||(a[0]=[o('<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /Java\\架构设计\\分布式\\06.分布式监控\\0_可观测性.md for this page in Markdown format</div><h1 id="分布式系统中的可观测性" tabindex="-1">分布式系统中的可观测性 <a class="header-anchor" href="#分布式系统中的可观测性" aria-label="Permalink to &quot;分布式系统中的可观测性&quot;">​</a></h1><h2 id="一、基本概念" tabindex="-1">一、基本概念 <a class="header-anchor" href="#一、基本概念" aria-label="Permalink to &quot;一、基本概念&quot;">​</a></h2><h3 id="分布式监控-monitoring" tabindex="-1">分布式监控（Monitoring） <a class="header-anchor" href="#分布式监控-monitoring" aria-label="Permalink to &quot;分布式监控（Monitoring）&quot;">​</a></h3><p>在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。</p><p>通过收集和分析各种指标数据来实现，例如CPU、内存、网络、磁盘等硬件指标，以及应用程序的请求、响应、日志等软件指标。通过监控这些指标，可以及时发现并解决系统的性能问题、故障和安全事件，保证系统的稳定运行和高效运作。</p><h3 id="可观测性-observability" tabindex="-1">可观测性（Observability） <a class="header-anchor" href="#可观测性-observability" aria-label="Permalink to &quot;可观测性（Observability）&quot;">​</a></h3><p>可观测性（Observability）指通过系统的外部输出推断其内部状态的能力。在软件开发中，可观测性是指通过日志、指标和追踪等数据，全面了解系统的运行状况，<strong>以便及时发现和解决问题</strong>。监控是针对系统健康状况的常规监护，而可观测则是对系统深层次内在逻辑的理解与解读，它通过获取更多元、更丰富的数据来提升系统管理和维护的效率与准确性。</p><p>可以简单将其理解为 “监控”，但它又比监控的概念更广更深，推荐阅读 <a href="https://www.aliyun.com/getting-started/what-is/what-is-observability" target="_blank" rel="noreferrer">大厂文档</a> 来进一步了解。</p><h2 id="二、相关概念" tabindex="-1">二、相关概念 <a class="header-anchor" href="#二、相关概念" aria-label="Permalink to &quot;二、相关概念&quot;">​</a></h2><h3 id="维度与指标" tabindex="-1">维度与指标 <a class="header-anchor" href="#维度与指标" aria-label="Permalink to &quot;维度与指标&quot;">​</a></h3><p>维度（Dimension）是用‌来描述和分类数据的标‍签属性，比如用户 ID、应用 ID、模型‍名称等，关注 “是什么”。</p><p>指标（Metric）是用来量‌化的数值数据，比如‍请求次数、响应时间‍、Token 消耗‍量等，关注 “有多少”。</p><p>简单来说，维度是可以用来筛选的标签，指标是用来计算的数值。</p><p>举个例子：</p><ul><li>维度：user_id=12345, app_id=67890, model_name=deepseek-chat</li><li>指标：requests_total=100, response_time=1.5s, tokens_used=2000</li></ul><h3 id="监控的数据分类" tabindex="-1">监控的数据分类 <a class="header-anchor" href="#监控的数据分类" aria-label="Permalink to &quot;监控的数据分类&quot;">​</a></h3><p>在实现可观测性时，我们需要关注多种不同类型的数据：</p><p>1）系统指‍标：包括 CPU ‌使用率、内存占用、‍磁盘 I/O、网络‍流量等基础设施层面的‍监控数据。</p><p>2）应用指‍标：涵盖接口响应时‌间、QPS（每秒查‍询率）、错误率、J‍VM 状态等应用层面的‍性能数据。HrGXUqFhjK7wNHkLfEF5cglTdzhFLxXIforC6kfYOak=</p><p>3）业务指‍标：针对我们平台的‌特定业务逻辑，比如‍ AI 模型调用次‍数、Token 消‍耗量、用户活跃度等。</p><p>4）调用链：在分布式系统中，一个请求可能经过多个服务组件。<strong>Trace</strong> 表示一个完整请求的调用链路，而 <strong>Span</strong> 则代表调用链中的一个操作单元。通过分析 Trace 和 Span，我们可以清晰地看到请求在系统中的流转过程，快速定位性能瓶颈。</p><p><img src="'+i+'" alt="img" loading="lazy"></p><h3 id="百分位数" tabindex="-1"><strong>百分位数</strong> <a class="header-anchor" href="#百分位数" aria-label="Permalink to &quot;**百分位数**&quot;">​</a></h3><p>在性能监控中，我们经常会看到 P50、P75、P90、P99 这些指标，它们被称为 <strong>百分位数</strong>。</p><ul><li>P50：中位数，表示 50% 的请求响应时间都在这个值以下</li><li>P75：75% 的请求响应时间都在这个值以下</li><li>P90：90% 的请求响应时间都在这个值以下</li><li>P99：99% 的请求响应时间都在这个值以下</li></ul><p>举个例子，如果一个接口‍的 P99 响应时间是 500ms，这意味着‌ 99% 的请求都能在 500ms 内完成，‍只有 1% 的请求可能超过这个时间。P99 ‍指标对于发现系统中的异常情况特别有用，因为它‍能反映出那些偶发的长尾延迟问题。</p><p><img src="'+l+'" alt="img" loading="lazy"></p><p>💡 注意，别把这玩意跟优先级 P0、P1、P2 搞混了。</p><h2 id="三、怎么实现" tabindex="-1">三、怎么实现 <a class="header-anchor" href="#三、怎么实现" aria-label="Permalink to &quot;三、怎么实现&quot;">​</a></h2><p>要构建完善的可观测性体系，我们需要解决几个核心问题：</p><p>1）统计什么？</p><p>需要根据业务特点确定关键指标，既要覆盖 <strong>系统层面</strong> 的通用指标，也要包含 <strong>业务特有</strong> 的监控维度。</p><p>2）如何收集？</p><p>数据收集是‍可观测性的基础，可‌以通过代码埋点、探‍针技术、日志分析等‍多种方式实现。</p><p>3）如何存储？</p><p>监控数据通‍常量大且连续，需要‌选择合适的存储方案‍，比如时序数据库或‍专门的监控系统。</p><p>4）如何展示？</p><p>最终需要通‍过直观的图表和仪表‌板将数据呈现给用户‍，一般会实时监控（‍页面自动刷新）。</p><h3 id="系统指标监控方式" tabindex="-1">系统指标监控方式 <a class="header-anchor" href="#系统指标监控方式" aria-label="Permalink to &quot;系统指标监控方式&quot;">​</a></h3><ol><li><p>利用 AR‍MS 平台进行系统指标监控‌：这是一种开箱即用的方案，‍通过集成阿里云 ARMS ‍等监控平台，可以快速获得系‍统层面的全面监控能力。</p></li><li><p>利用 Prometheus + Grafana 自定义业务指标监控：这是目前最主流的开源监控方案，提供了强大的自定义能力和丰富的生态支持。</p><p><strong>💡</strong> 其实大多数非企业级的项目，直接利用数据库和日志进行业务指标统计也足够了。毕竟多接入一个系统，就多一份成本。</p></li><li><p>Spring 自带的监控工具</p><ul><li><p>使用 Spring Boot Actuator：Spring Boot Actuator 是 Spring Boot 提供的一个监控和管理 Spring Boot 应用的工具。提供了丰富的端点，包括健康检查、性能指标、日志等，可以通过 HTTP 访问这些端点来获取应用的状态信息。</p></li><li><p>使用 Spring Cloud Sleuth：Spring Cloud Sleuth 是 Spring Cloud 提供的一个分布式跟踪解决方案，它可以帮助我们跟踪微服务调用的路径、耗时等信息。通过集成 Sleuth，可以获取到微服务之间调用的链路信息，从而进行性能分析和故障排查。</p></li><li><p>使用 Spring Cloud Metrics：Spring Cloud Metrics 是 Spring Cloud 提供的一个度量监控框架，它可以帮助我们获取微服务应用的度量指标，如 CPU 使用率、内存使用率、线程池信息等。通过收集和展示这些度量指标，可以更好地了解微服务应用的运行状态和性能瓶颈。</p></li></ul></li></ol><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><p>如何监控微服务调用：<a href="https://blog.csdn.net/qq_37756660/article/details/134860073" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_37756660/article/details/134860073</a></p><p>分布式架构的监控与指标：<a href="https://cloud.tencent.com/developer/article/2375812" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/2375812</a></p><p>可观测性与监控的区别：<a href="https://zhuanlan.zhihu.com/p/469580402" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/469580402</a></p><p>各种工具调用链对比：<a href="https://blog.csdn.net/u010191034/article/details/131474830" target="_blank" rel="noreferrer">https://blog.csdn.net/u010191034/article/details/131474830</a></p><p>各种工具调用链对比：<a href="https://blog.51cto.com/u_16213575/7699547" target="_blank" rel="noreferrer">https://blog.51cto.com/u_16213575/7699547</a></p><p>阿修罗监控AsuraMonitor：<a href="https://gitee.com/asuramonitor/monitor" target="_blank" rel="noreferrer">https://gitee.com/asuramonitor/monitor</a></p>',48)])])}const b=e(n,[["render",p]]);export{m as __pageData,b as default};
