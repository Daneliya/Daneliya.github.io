import{_ as s,c as n,o as l,aN as e}from"./chunks/framework.CMIDsdwV.js";const p="/assets/20190606180834733.D5tqJdTS.png",i="/assets/image-20240402010612109.DkxR69QM.png",r="/assets/nUhEtf9xLKZX7Q2.C-pGjcxS.png",t="/assets/image-20240403001518713.VdjtGtrM.png",o="/assets/image-20240403002146866.BaeHsCzu.png",c="/assets/image-20240405015332787.CfRrV_fw.png",d="/assets/image-20240405020042915.bsGAaJUS.png",h="/assets/image-20240405020308355.D0f6VSw2.png",b="/assets/image-20240405020710688.BnkLyGJK.png",u="/assets/image-20240405225245679.6TGUhmbQ.png",m="/assets/20201022161828318.DQVAvxO3.png",g="/assets/20201022170824339.yqcJYwn2.png",k="/assets/4f8570206a4b4d40bf7f03e7b488205a.DlP5ahtZ.png",E="/assets/image-20240407001349605.DyUvij5e.png",A="/assets/bb0592deffb84b52a6578b19f03f9c8d.BnJq1gW7.jpeg",P=JSON.parse('{"title":"数据库技术基础","description":"","frontmatter":{"title":"数据库技术基础","tags":["中级软件设计师"],"categories":["中级软件设计师"]},"headers":[],"relativePath":"daily/软件设计师/09_数据库技术基础.md","filePath":"daily/软件设计师/09_数据库技术基础.md","lastUpdated":1767444225000}'),q={name:"daily/软件设计师/09_数据库技术基础.md"};function f(C,a,v,_,y,B){return l(),n("div",null,[...a[0]||(a[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /daily\\软件设计师\\09_数据库技术基础.md for this page in Markdown format</div><h1 id="数据库技术基础" tabindex="-1">数据库技术基础 <a class="header-anchor" href="#数据库技术基础" aria-label="Permalink to &quot;数据库技术基础&quot;">​</a></h1><h2 id="数据库的基本概念" tabindex="-1">数据库的基本概念 <a class="header-anchor" href="#数据库的基本概念" aria-label="Permalink to &quot;数据库的基本概念&quot;">​</a></h2><p>考点1：数据库体系结构</p><p>考点2：三级模式结构</p><p>考点3：数据仓库</p><h3 id="考点1-数据库体系结构" tabindex="-1">考点1：数据库体系结构 <a class="header-anchor" href="#考点1-数据库体系结构" aria-label="Permalink to &quot;考点1：数据库体系结构&quot;">​</a></h3><h4 id="数据库系统的体系结构" tabindex="-1">💐数据库系统的体系结构 <a class="header-anchor" href="#数据库系统的体系结构" aria-label="Permalink to &quot;:bouquet:数据库系统的体系结构&quot;">​</a></h4><ol><li>集中式数据库系统 <ul><li>数据是集中的</li><li>数据管理是集中的</li><li>数据库系统的素有功能 (从形式的用户接口到DBMS核心)都集中在DBMS所在的计算机。</li></ul></li><li>C/S结构 <ul><li>客户端负责数据表示</li><li>服务服务器主要负责数据库服务</li><li>数据库系统分为前端和后端</li><li>ODBC、JDBC</li></ul></li><li>分布式数据库 <ul><li>物理上分布、逻辑上集中</li><li>物理上分布、逻辑上分布</li><li>特点</li><li>透明性</li></ul></li><li>并行数据库 <ul><li>共享内存式</li><li>无共享式</li></ul></li></ol><h4 id="分布式数据库特点" tabindex="-1">💐分布式数据库特点 <a class="header-anchor" href="#分布式数据库特点" aria-label="Permalink to &quot;:bouquet:分布式数据库特点&quot;">​</a></h4><ol><li><strong>数据独立性</strong>。除了数据的逻辑独立性与物理独立性外，还有数据分布独立性（分布透明性）。</li><li><strong>集中与自治共享结合的控制结构</strong>。各局部的DBMS可以独立地管理局部数据库，具有自治的功能。同时，系统又设有集中控制机制，协调各局部DBMS的工作，执行全局应用。</li><li><strong>适当增加数据冗余度</strong>。在不同的场地存储同一数据的多个副本，可以提高<strong>系统的可靠性和可用性</strong>，同时也能提高系统性能。（提高系统的可用性，即当系统中某个节点发生故障时，因为数据有其他副本在非故障场地上，对其他所有场地来说，数据仍然是可用的，从而保证数据的完备性）。</li><li><strong>全局的一致性、可串行性和可恢复性</strong>。</li></ol><h4 id="分布式数据库透明性" tabindex="-1">💐分布式数据库透明性 <a class="header-anchor" href="#分布式数据库透明性" aria-label="Permalink to &quot;:bouquet:分布式数据库透明性&quot;">​</a></h4><ol><li><strong>分片透明</strong>：是指用户不必关心数据是如何分片的，它们对数据的操作在全局关系上进行，即如何分片对用户是透明的。</li><li><strong>复制透明</strong>：用户不用关心数据库在网络中各个节点的复制情况，被复制的数据的更新都由系统自动完成。</li><li><strong>位置透明</strong>：是指用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。</li><li><strong>局部映像透明性（逻辑透明）</strong>：是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关心局部DBMS支持哪种数据模型、使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的，因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。</li></ol><h4 id="例题" tabindex="-1">💐例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;:bouquet:例题&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>在分布式数据库中有分片透明、复制透明、位置透明和逻辑透明等基本概念，其中: (D)是指局部数据模型透明，即用户或应用程序无需知道局部使用的是哪种数据模型; (A) 是指用户或应用程序不需要知道逻辑上访问的表具体是如何分块存储的。</span></span>
<span class="line"><span>A分片透明 B复制透明 C位置透明 D逻辑透明</span></span>
<span class="line"><span>A分片透明 B复制透明 C位置透明 D逻辑透明</span></span>
<span class="line"><span></span></span>
<span class="line"><span>当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪。这称为分布式数据库的 (C)。</span></span>
<span class="line"><span>A共享性</span></span>
<span class="line"><span>B自治性</span></span>
<span class="line"><span>C可用性</span></span>
<span class="line"><span>D分布性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="考点2-三级模式结构" tabindex="-1">考点2：三级模式结构 <a class="header-anchor" href="#考点2-三级模式结构" aria-label="Permalink to &quot;考点2：三级模式结构&quot;">​</a></h3><h4 id="三级模式和两级映像" tabindex="-1">🌸三级模式和两级映像 <a class="header-anchor" href="#三级模式和两级映像" aria-label="Permalink to &quot;:cherry_blossom:三级模式和两级映像&quot;">​</a></h4><p><img src="`+p+`" alt="img" loading="lazy"></p><p>三级模式</p><ol><li>用户级--&gt; 外模式(反映了数据库系统的用户观) <ul><li>外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%A1%A8%E7%A4%BA" target="_blank" rel="noreferrer">逻辑表示</a>。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95" target="_blank" rel="noreferrer">数据记录</a>(外模式)，也可以利用<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80" target="_blank" rel="noreferrer">数据操纵语言</a>(Data Manipulation Language，DML)对这些数据记录进行操作。</li></ul></li><li>概念级--&gt; 概念模式（反映了数据库系统的整体观） <ul><li>概念模式又称模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。</li></ul></li><li>物理级 --&gt; 内模式（反映了数据库系统的存储观） <ul><li>内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。</li></ul></li></ol><p>两级映射</p><ol><li>外模式/模式的映像：实现外模式到概念模式之间的相互转换。 <ul><li>逻辑独立性：数据的逻辑独立性是指用户的应用程序与数据库结构是相互独立的。数据的逻辑结构发生变化后，用户程序也可以不修改。但是，为了保证应用程序能够正确执行，需要修改外模式/概念模式之间的映像。</li></ul></li><li>模式/内模式的映像：实现概念模式到内模式之间的相互转换。 <ul><li>物理独立性：数据的物理独立性是指当数据库的内模式发生改变时，数据的的逻辑结构不变。由于应用程序处理的只是数据的逻辑结构，这样物理独立性可以保证，当数据的物理结构改变了，应用程序不用改变。但是，为了保证应用程序能够正确执行，需要修改概念模式/内模式之间的映像。</li></ul></li></ol><p><a href="https://blog.csdn.net/mcb520wf/article/details/91047683" target="_blank" rel="noreferrer">数据库模式（三级模式+两级映射）_数据库的物理连接属于什么模式-CSDN博客</a></p><h4 id="例题-1" tabindex="-1">🌸例题 <a class="header-anchor" href="#例题-1" aria-label="Permalink to &quot;:cherry_blossom:例题&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数据库系统通常采用三级模式结构:外模式、模式和内模式。这三级模式分别对应数据库的(B)</span></span>
<span class="line"><span>A基本表、存储文件和视图</span></span>
<span class="line"><span>B视图、基本表和存储文件</span></span>
<span class="line"><span>C基本表、视图和存储文件</span></span>
<span class="line"><span>D视图、存储文件和基本表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>以下关于数据库两级映像的叙述中，正确的是(B)</span></span>
<span class="line"><span>A模式/内模式映像实现了外模式到内模式之间的相互转换</span></span>
<span class="line"><span>B模式/内模式映像实现了概念模式到内模式之间的相互转换</span></span>
<span class="line"><span>C外模式/模式的映像实现了概念模式到内模式之间的相互转换</span></span>
<span class="line"><span>D外模式/内模式的映像实现了外模式到内模式之间的相互转换</span></span>
<span class="line"><span></span></span>
<span class="line"><span>数据的物理独立性和逻辑独立性分别是通过修改 (D) 来完成的。</span></span>
<span class="line"><span>A外模式与内模式之间的映像、模式与内模式之间的映像</span></span>
<span class="line"><span>B外模式与内模式之间的映像、外模式与模式之间的映像</span></span>
<span class="line"><span>C外模式与模式之间的映像、模式与内模式之间的映像</span></span>
<span class="line"><span>D模式与内模式之间的映像、外模式与模式之间的映像</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="考点3-数据仓库" tabindex="-1">考点3：数据仓库 <a class="header-anchor" href="#考点3-数据仓库" aria-label="Permalink to &quot;考点3：数据仓库&quot;">​</a></h3><h4 id="数据仓库特点" tabindex="-1">🌷数据仓库特点 <a class="header-anchor" href="#数据仓库特点" aria-label="Permalink to &quot;:tulip:数据仓库特点&quot;">​</a></h4><ol><li>面向主题：数据按主题组织。</li><li>集成的：消除了源数据中的不一致性，提供整个企业的一致性全局信息。</li><li>相对稳定的（非易失的）：主要进行查询操作，只有少量的修改和删除操作（或是不删除）。</li><li>反映历史变化（随着时间变化）：记录了企业从过去某一时刻到当前各个阶段的信息，可对发 展历程和未来趋势做定量分析和预测。</li></ol><p><img src="`+i+`" alt="image-20240402010612109" loading="lazy"></p><p><a href="https://zhuanlan.zhihu.com/p/433495465" target="_blank" rel="noreferrer">什么是数据仓库？它和数据库的区别是什么？看这一篇就够了 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/hello_java_lcl/article/details/107025192" target="_blank" rel="noreferrer">数据仓库--数据分层（ETL、ODS、DW、APP、DIM）_数仓分层dim-CSDN博客</a></p><h4 id="例题-2" tabindex="-1">🌷例题 <a class="header-anchor" href="#例题-2" aria-label="Permalink to &quot;:tulip:例题&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>某集团公司下属有多个超市，每个超市的所有销售数据最终要存入公司的数据仓库中。假设该公司高管需要从时间、地区和商品种类三个维度来分析某家电商品的销售数据，那么最适合采用(B) 来完成。</span></span>
<span class="line"><span>A DataExtraction 数据清理</span></span>
<span class="line"><span>B OLAP 连接分析</span></span>
<span class="line"><span>C OLTP 事务</span></span>
<span class="line"><span>D ETL 抽取</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="数据库设计过程" tabindex="-1">数据库设计过程 <a class="header-anchor" href="#数据库设计过程" aria-label="Permalink to &quot;数据库设计过程&quot;">​</a></h2><h3 id="数据库设计过程-1" tabindex="-1">数据库设计过程 <a class="header-anchor" href="#数据库设计过程-1" aria-label="Permalink to &quot;数据库设计过程&quot;">​</a></h3><h4 id="数据库设计过程图" tabindex="-1">数据库设计过程图 <a class="header-anchor" href="#数据库设计过程图" aria-label="Permalink to &quot;数据库设计过程图&quot;">​</a></h4><p><img src="`+r+`" alt="软考-数据库设计过程" loading="lazy"></p><p>数据流图简称（OFD）</p><p>数据字典简称（DD）</p><p>聚簇索引在物理设计里</p><h4 id="例题-3" tabindex="-1">例题 <a class="header-anchor" href="#例题-3" aria-label="Permalink to &quot;例题&quot;">​</a></h4><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>关系规范化在数据库设计的 (C) 阶段进行。</span></span>
<span class="line"><span>A需求分析</span></span>
<span class="line"><span>B概念设计</span></span>
<span class="line"><span>C逻辑设计</span></span>
<span class="line"><span>D物理设计</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="概念设计阶段" tabindex="-1">概念设计阶段 <a class="header-anchor" href="#概念设计阶段" aria-label="Permalink to &quot;概念设计阶段&quot;">​</a></h3><h4 id="考点1-概念设计过程" tabindex="-1">考点1：概念设计过程 <a class="header-anchor" href="#考点1-概念设计过程" aria-label="Permalink to &quot;考点1：概念设计过程&quot;">​</a></h4><p><img src="`+t+'" alt="image-20240403001518713" loading="lazy"></p><p>集成的方法：</p><ol><li>多个局部E-R图一次集成。</li><li>逐步集成，用累加的方式一次集成两个局部E-R。</li></ol><p>集成产生的冲突及解决办法：（针对同一对象）</p><ol><li>居性冲突：包括属性域冲突和属性取值冲突。</li><li>命名冲突：包括同名异义和异名同义。</li><li>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部E-R图中所包含的属性个数和属性排列次序不完全相同。</li></ol><h4 id="考点2-e-r图" tabindex="-1">考点2：E-R图 <a class="header-anchor" href="#考点2-e-r图" aria-label="Permalink to &quot;考点2：E-R图&quot;">​</a></h4><h5 id="e-r模型" tabindex="-1">E-R模型 <a class="header-anchor" href="#e-r模型" aria-label="Permalink to &quot;E-R模型&quot;">​</a></h5><p><img src="'+o+'" alt="image-20240403002146866" loading="lazy"></p><p>**实体型：**用矩形表示，矩形框内写明实体名。</p><p>**属性：**用椭圆形表示，并用无向边将其与相应的实体型连接起来。</p><p>**联系：**用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1∶1，1∶n或m∶n）。（联系可以具有属性）。</p><p><strong>特殊化</strong>：用线条加圈或者矩形加平行线。</p><p>实体：实体是现实世界中可以区别于其他对象的事件或事物。(实体集一实体的集合)</p><p>属性：居性是实体某方面的特性。</p><p>联系：突体的联系分为实体内部的联系和实体与实体间的联系。实体间联系类型: 1:1，1:*，*:*</p><h5 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h5><ol><li>简单属性和复合属性 <ul><li><strong>简单属性</strong>是原子的，不可再分的；</li><li><strong>复合属性</strong>可以细分为更小的部分 (即划分为别的属性)</li></ul></li><li>单值属性和多值属性 <ul><li>定义的属性对于一个特定的实体都只有单独的一个值，称为单值属性</li><li>在某些特定情况下，一个属性可能对应一组值，称为多值属性。</li></ul></li><li>NULL属性：表示无意义或不知道。</li><li>派生属性：可以从其他属性得来。</li></ol><h5 id="联系类型判断" tabindex="-1">联系类型判断 <a class="header-anchor" href="#联系类型判断" aria-label="Permalink to &quot;联系类型判断&quot;">​</a></h5><p>两个不同实体集之间联系</p><ul><li><p>一对一（1:1）</p></li><li><p>一对多（1:n）</p></li><li><p>多对多（m:n）</p></li></ul><p>两个以上不同实体集之间的联系（三元联系）多重度的确定可根据语义直接转换</p><ul><li>以三元关系中的一个实体作为中心，假设另两个实体都只有一个实例；</li><li>若中心实体只有一个实例能与另两个实体的一个实例进行关联，则中心实体的连通数为“一”；</li><li>若中心实体有多于一个实例能与另两个实体实例进行关联，则中心实体的连通数为“多”。</li></ul><p>同一个实体集内的二元联系</p><h5 id="扩充的e-r模型" tabindex="-1">扩充的E-R模型 <a class="header-anchor" href="#扩充的e-r模型" aria-label="Permalink to &quot;扩充的E-R模型&quot;">​</a></h5><p>弱实体：在现实世界中有一种特殊的依赖联系;该联系是指某实体是否存在对于另些实体具有很强的依赖关系，即一个实体的存在必须以另一个实体为前提，而将这类实体称为弱实体，如家属与职工的联系，附件与邮件。 特殊化：在现实世界中，某些实体一方面具有一些共性，另一方面还只有各自的特性，一个实体集可以按照某些特征区分为几个子实体。</p><p>聚集：一个联系作为另一个联系的一端。</p><h3 id="逻辑结构设计" tabindex="-1">逻辑结构设计 <a class="header-anchor" href="#逻辑结构设计" aria-label="Permalink to &quot;逻辑结构设计&quot;">​</a></h3><h4 id="考点1-关系模式相关概念" tabindex="-1">考点1：关系模式相关概念 <a class="header-anchor" href="#考点1-关系模式相关概念" aria-label="Permalink to &quot;考点1：关系模式相关概念&quot;">​</a></h4><h5 id="数据模型" tabindex="-1">数据模型 <a class="header-anchor" href="#数据模型" aria-label="Permalink to &quot;数据模型&quot;">​</a></h5><p>层次模型</p><p>网状模型</p><p>关系模型</p><p>面向对象模型</p><p>注：数据模型三要素:数据结构、数据操作、数据的约束条件</p><h5 id="关系模型相关概念" tabindex="-1">关系模型相关概念 <a class="header-anchor" href="#关系模型相关概念" aria-label="Permalink to &quot;关系模型相关概念&quot;">​</a></h5><ul><li>目或度：关系模式中属性的个数</li><li>侯选码（候选键）</li><li>主码（主键）</li><li>主属性与非主属性：组成候选码的属性就是主属性，其它的就是非主属性。</li><li>外码（外键）</li><li>全码（ALL-Key）：关系模式的所有属性组是这个关系的候选码。</li></ul><h5 id="关系的3种类型" tabindex="-1">关系的3种类型 <a class="header-anchor" href="#关系的3种类型" aria-label="Permalink to &quot;关系的3种类型&quot;">​</a></h5><ol><li>基本关系</li><li>查询表</li><li>视图表</li></ol><h5 id="完整性约束" tabindex="-1">完整性约束 <a class="header-anchor" href="#完整性约束" aria-label="Permalink to &quot;完整性约束&quot;">​</a></h5><ol><li>实体完整性约束（主键：唯一、非空）</li><li>参照完整性约束（外键：其他关系主键或为空）</li><li>用户自定义完整性约束（check条件）</li></ol><p>注：触发器完成复杂完整性约束条件设定</p><h4 id="考点2-e-r图转关系模式" tabindex="-1">考点2：E-R图转关系模式 <a class="header-anchor" href="#考点2-e-r图转关系模式" aria-label="Permalink to &quot;考点2：E-R图转关系模式&quot;">​</a></h4><h5 id="逻辑结构设计-e-r模型转关系模式" tabindex="-1">逻辑结构设计-E-R模型转关系模式 <a class="header-anchor" href="#逻辑结构设计-e-r模型转关系模式" aria-label="Permalink to &quot;逻辑结构设计-E-R模型转关系模式&quot;">​</a></h5><ul><li>一个实体型必须转换为一个关系模式</li><li>联系转关系模式</li></ul><p><img src="'+c+'" alt="image-20240405015332787" loading="lazy"></p><p>（1）一对一联系的转换有两种方式。</p><ul><li>独立的关系模式：并入两端主键及联系自身属性。（主键：任一键主键）</li><li>归并（可以并入任意一端）：并入另一端主键及联系自身属性。（主键：保持不变）</li></ul><p><img src="'+d+'" alt="image-20240405020042915" loading="lazy"></p><p>（2）一对多联系的转换有两种方式。</p><ul><li>独立的关系模式：并入两端主键及联系自身属性。（主键：多端主键）</li><li>归并（只能并入多端）：并入另一端主键及联系自身属性。（主键：保持不变）</li></ul><p><img src="'+h+'" alt="image-20240405020308355" loading="lazy"></p><p>（3）多对多联系的转换只有一种方式</p><ul><li>独立的关系模式：并入两端主键及联系自身属性。 （主键：两端主键的组合键）</li></ul><p><img src="'+b+'" alt="image-20240405020710688" loading="lazy"></p><h5 id="e-r图转关系模式" tabindex="-1">E-R图转关系模式 <a class="header-anchor" href="#e-r图转关系模式" aria-label="Permalink to &quot;E-R图转关系模式&quot;">​</a></h5><table tabindex="0"><thead><tr><th>联系类型</th><th>实体（独立关系模式）</th><th>联系（独立关系模式）</th><th>联系（归并关系模式）</th><th>备注</th></tr></thead><tbody><tr><td>1对1</td><td>√</td><td>√</td><td>√</td><td>并入任一端</td></tr><tr><td>1对多</td><td>√</td><td>√</td><td>√</td><td>并入多端</td></tr><tr><td>多对多</td><td>√</td><td>√</td><td>×</td><td></td></tr></tbody></table><h2 id="关系代数" tabindex="-1">关系代数 <a class="header-anchor" href="#关系代数" aria-label="Permalink to &quot;关系代数&quot;">​</a></h2><p>（2-4分）</p><h3 id="关系代数–并、交、差" tabindex="-1">关系代数–并、交、差 <a class="header-anchor" href="#关系代数–并、交、差" aria-label="Permalink to &quot;关系代数–并、交、差&quot;">​</a></h3><p><img src="'+u+'" alt="image-20240405225245679" loading="lazy"></p><p>垂直：属性列，目，度</p><p>水平：元组行，记录，实例</p><p>并(结果为二者元组之和去除重复行)</p><p>交(结果为二者重复行)</p><p>差(前者去除二者重复行)</p><h3 id="关系代数–笛卡尔积、投影、选择" tabindex="-1">关系代数–笛卡尔积、投影、选择 <a class="header-anchor" href="#关系代数–笛卡尔积、投影、选择" aria-label="Permalink to &quot;关系代数–笛卡尔积、投影、选择&quot;">​</a></h3><p><img src="'+m+'" alt="在这里插入图片描述" loading="lazy"></p><p>笛卡尔积：属性列数为二者属性列数之和，元组行数为二者乘积。</p><p>投影：对属性列的选择列出，就是把需要的字段显示出来即可。</p><p>选择：选择是根据某些条件对关系做水平切割，对元组行的选择列出如上述中Sn0-Sn0003(S1)，是指从S1中选择Sno字段为Snooo3的数据。</p><p>选择操作不会操作表格结构，笛卡尔积和投影可能会修改</p><h3 id="关系代数–自然连接" tabindex="-1">关系代数–自然连接 <a class="header-anchor" href="#关系代数–自然连接" aria-label="Permalink to &quot;关系代数–自然连接&quot;">​</a></h3><p><img src="'+g+`" alt="在这里插入图片描述" loading="lazy"></p><p>自然连接：属性列数是二者之和减去重复列数，元祖行与同名属性列取值相等</p><p>性能比较：</p><p>自然连接&gt;笛卡尔</p><p>两侧数据应尽量先压缩、筛选</p><p>select 是投影的结果</p><p>from 多个表格是笛卡尔的结果</p><p>where 选择</p><h3 id="例题-4" tabindex="-1">例题 <a class="header-anchor" href="#例题-4" aria-label="Permalink to &quot;例题&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>给定关系R (A，B，C，D)和关系S (A，C，E，F)，对其进行自然连接运R&amp;S算后的属性列为 (C)个;</span></span>
<span class="line"><span>与oR.B&gt;S.E(R&amp;S)等价的关系代数表达式为(B)</span></span>
<span class="line"><span>A 4  B 5   C 6     D 8</span></span>
<span class="line"><span>A σ2&gt;7(R×S)</span></span>
<span class="line"><span>B π1,2,3,4,7,8(σ1=5∧2&gt;7∧3=6(R×S))</span></span>
<span class="line"><span>C σ2&gt;&#39;7&#39;(R×S)</span></span>
<span class="line"><span>D π1,2,3,4,7,8(σ1=5∧2&gt;&#39;7&#39;∧3=6(R×S))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>下列查询B=“大数据”且F=“开发平台”，结果集属性列为A、B、C、F的关系代致表达式中，查询效率最高的是 (D) 。</span></span>
<span class="line"><span>A π1,2,3,8(σ2=&#39;大数据&#39;∧1=5∧3=6∧8=&#39;开发平台&#39;(R×S))</span></span>
<span class="line"><span>B π1,2,3,8(σ1=5∧3=6∧8=&#39;开发平台&#39;(σ2=&#39;大数据&#39;(R)×S)</span></span>
<span class="line"><span>C π1,2,3,8(σ2=&#39;大数据&#39;∧1=5&gt;3=6(R×σ4=&#39;开发平台&#39;(S))</span></span>
<span class="line"><span>D π1,2,3,8(σ1=5∧3=6(σ2=&#39;大数据&#39;(R)×σ4=&#39;开发平台&#39;(S))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><a href="https://blog.csdn.net/JavaEEKing/article/details/109223552" target="_blank" rel="noreferrer">数据库系统之：关系代数详解-超详细_数据库关系代数-CSDN博客</a></p><h2 id="规范化理论" tabindex="-1">规范化理论 <a class="header-anchor" href="#规范化理论" aria-label="Permalink to &quot;规范化理论&quot;">​</a></h2><p>考点1：规范化理论基本概念</p><p>考点2：范式判断</p><p>考点3：模式分解</p><h3 id="考点1-规范化理论基本概念" tabindex="-1">考点1：规范化理论基本概念 <a class="header-anchor" href="#考点1-规范化理论基本概念" aria-label="Permalink to &quot;考点1：规范化理论基本概念&quot;">​</a></h3><p>考的很频繁（上午2分，下午可能有）</p><h4 id="函数依赖" tabindex="-1">函数依赖 <a class="header-anchor" href="#函数依赖" aria-label="Permalink to &quot;函数依赖&quot;">​</a></h4><p><strong>定义</strong>：设R(U)是属性U上的一个关系模式，X和Y是U的子集，r为R的任一关系，如果对于r中的任意两个元组u，v，只要有u[X]=v[X]，就有u[Y]=v[Y]，则称X函数决定Y，或称Y函数依赖于X，记为X→Y。（X决定因素，Y被决定因素）</p><p>函数依赖可扩展以下两种规则：</p><ol><li><strong>部分函数依赖</strong>：A可确定C，（A，B）也可确定C，（A，B）中的一部分（即A）可以确定C，称为部分函数依赖。</li><li><strong>传递函数依赖</strong>：当A和B不等价时，A可确定B，B可确定C，则A可确定C，是传递函数依赖；若A和B等价，则不存在传递，直接就可确定C。</li></ol><p><img src="`+k+'" alt="在这里插入图片描述" loading="lazy"></p><h4 id="规范化理论一amstrong公理体系" tabindex="-1">规范化理论一Amstrong公理体系 <a class="header-anchor" href="#规范化理论一amstrong公理体系" aria-label="Permalink to &quot;规范化理论一Amstrong公理体系&quot;">​</a></h4><p>关系模式R&lt;U，F&gt;来说有以下的推理规则:</p><p>A1.<strong>自反律</strong> (Reflexivity) ：若Y∈X∈U，则X→Y成立。</p><p>A2.<strong>增广律</strong> (Augmentation) ：若Z∈U且X→Y，则XZ→YZ成立。</p><p>A3.<strong>传递律</strong> (Transitivity) ：若X→Y且Y→Z，则X→Z成立。</p><p>根据A1，A2，A3这三条推理规则可以得到下面三条推理规则：</p><p><strong>合并规则</strong>：由X→Y，X→Z，有X→YZ。(A2，A3)</p><p><strong>伪传递规则</strong>：由X→Y，WY→Z，有XW→Z。(A2，A3)</p><p><strong>分解规则</strong>：由X→Y及Z∈Y，有X→Z。(A1，A3)</p><h4 id="候选键" tabindex="-1">候选键 <a class="header-anchor" href="#候选键" aria-label="Permalink to &quot;候选键&quot;">​</a></h4><p>超键：能唯一标识此表的属性的组合。</p><p>候选键：超键中去掉冗余的属性，剩余的属性就是候选键。</p><p>主键：任选一个候选键，即可作为主键。</p><p>外键：其他表中的主键。</p><p>图示法求候选</p><ol><li>将关系的函数依赖关系，用“有向图”的方式表示。</li><li>找出<strong>入度为0</strong>的属性，并以该属性集合为起点，尝试遍历有向图，若能正常遍历图中所有结点，则该属性集即为关系模式的候选键。</li><li>若入度为0的属性集不能遍历图中所有结点，则需要尝试性的将一些<strong>中间结点</strong> (既有入度，也有出度的结点)并入入度为0的属性集中，直至该集合能遍历所有结点，集合为候选键。</li></ol><p><img src="'+E+`" alt="image-20240407001349605" loading="lazy"></p><h4 id="主属性与非主属性" tabindex="-1">主属性与非主属性 <a class="header-anchor" href="#主属性与非主属性" aria-label="Permalink to &quot;主属性与非主属性&quot;">​</a></h4><p>主属性：候选键内的属性为主属性，其他属性为非主属性。</p><div class="language-markdown vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例1: 关系模式CSZ(CITV，ST，ZIP）, 其属性组上的函数依赖集为:F={（CITV，ST）→ZIP，ZIP→CITV},其中CITY表示城市，ST表示街道，ZIP表示邮政编码。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">候选键有两个，都为组合键：（ST，CITV）（ST，ZIP）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">主属性：CITV，ST，ZIP</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">非主属性：没有</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例2: 若给定的关系模式为R，U={A,B,C}， F={AB→C,C→B}，则关系R(B)。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A有2个候选关键字AC和BC，并且有3个主属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">B有2个候选关键字AC和AB，并且有3个主属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">C只有一个候选关键字AC，并且有1个非主属性和2个主属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D 只有一个候选关键字AB，并且有1个非主属性和2个主属性</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例3: 给定关系模式R(U，F)，其中:U为关系模式R中的属性集，F是U上的一组函数依赖。假设U={A1，A2，A3，A4}，F={A1→A2，A1A2→A3，A1→A4，A2→A4}，那么关系R的主键应为 (A)。函数依赖集F中的(D)是冗余的。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A A1     B A1A2     C A1A3   D A1A2A3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A A1→A2  B A1A2→A3  C A1→A4  D A2→A4</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例4: 给定关系模式RU，F&gt;，其中U为属性集，F是U上的一组函数依赖，那么Armstrong公理系统的伪传递律是指 (B)。问题1选项</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A 若X→Y，X→Z，则X→YZ为F所蕴涵   合并律</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">B 若X→Y，WY→Z，则XW→Z为F所蕴涵    伪传递律</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">C 若X→Y，Y→Z为F所蕴涵，则X→Z为F所蕴涵   传递率</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D 若X→Y为F所蕴涵，且Z∈U，则XZ→YZ为F所蕴涵    增广律</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>实体完整性约束：即主键约束，主键值不能为空，也不能重复。</p><p>参照完整性约束：即外键约束，外键必须是其他表中已经存在的主键的值，或者为空。</p><p>用户自定义完整性约束：自定义表达式约束，如设定年龄属性的值必须在0到150之间。</p><h3 id="考点2-范式判断" tabindex="-1">考点2：范式判断 <a class="header-anchor" href="#考点2-范式判断" aria-label="Permalink to &quot;考点2：范式判断&quot;">​</a></h3><p>规范化问题：</p><p>数据冗余</p><p>修改异常</p><p>插入异常</p><p>删除异常</p><p>第一范式1NF：在关系模式R中，当且仅当所有域只包含原子值，即每个属性都是不可再分的数据项，则称关系模式R是第一范式。</p><p>第二范式2NF：当且仅当R是1NF，且每一个非主属性完全依赖主键（不存在部分依赖）时，R就是2NF。</p><p>比较典型的例子就是候选键是单属性，单属性是不可能存在部分函数依赖的。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>思考题: 关系模式SC(学号，课程号，成绩，学分)，其中: (学号，课程号一成绩，课程号一学分，会存在哪些问题 (从数据兄余、更新异常、插入异常、删除异常这几个方面来考虑)，解决方案是什么?</span></span>
<span class="line"><span>1、找候选键（学号、课程号）</span></span>
<span class="line"><span>2、找非主属性（成绩、学分）</span></span>
<span class="line"><span>3、判断非主属性是否存在对候选键的部分函数依赖。组合候选键中学号可以决定非主属性学分，所以存在，只满足第一范式。（学号，课程号一成绩）（课程号一学分）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>第三范式3NF：当且仅当R是2NF，且R中没有非主属性传递依赖于候选键时，R就是3NF（此时，也不会存在部分依赖）。</p><p>一般解决方法是拆分传递依赖的非主属性为一个新的关系模式。本质就是主键要直接决定所有非主属性，不能通过非主属性间接决定。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>思考题:学生关系 (学号，姓名，系号，系名，系位置)各属性分别代表学号，姓名，所在系号，系名称，系地址。思考该关系模式会存在哪些问题 (从数据冗余、更新异常、插入异常、删除异常这几个方面来考虑)，解决方案是什么?</span></span>
<span class="line"><span>1、找候选键（学号）。单属性候选键，至少满足第二范式</span></span>
<span class="line"><span>2、找非主属性（姓名，系号，系名，系位置）</span></span>
<span class="line"><span>3、判断是否满足3NF。不满足。(学号，姓名，系号)(系号，系名，系位置)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>BC范式 (BCNF)：设R是一个关系模式，F是它的依赖集，R属于BCNF当且仅当其F中<strong>每个依赖的决定因素必定包含R的某个候选码</strong>。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>例: 关系模式ST (S，T，J ）中，S表示学生，T表示老师，J表示课程。每一老师只教一门课程。每门课程有若干老师，某一学生选定某门课，就对应一个固定老师。</span></span>
<span class="line"><span>（T——J）（SJ——T）</span></span>
<span class="line"><span>1、找候选键（SJ、ST）</span></span>
<span class="line"><span>2、找非主属性（无）</span></span>
<span class="line"><span>3、判断2NF。没有非主属性，也就没有非主属性对候选键的部分函数依赖</span></span>
<span class="line"><span>4、判断3NF。没有非主属性，也就没有非主属性对候选键的陈传递依赖。</span></span>
<span class="line"><span>5、判断BC。关系一中决定因素T不包含候选键</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><img src="`+A+`" alt="数据库范式（1NF、2NF、3NF、BCNF）_1nf,2nf,3nf,bcnf的理解-CSDN博客" loading="lazy"></p><table tabindex="0"><thead><tr><th>范式</th><th>属性不可再分</th><th>非主属性部分函数依赖于候选键</th><th>非主属性传递函数依赖于候选键</th><th>函数依赖左侧决定因素包含候选键</th></tr></thead><tbody><tr><td>1NF</td><td>√</td><td>存在</td><td></td><td></td></tr><tr><td>2NF</td><td>√</td><td>不存在</td><td>存在</td><td></td></tr><tr><td>3NF</td><td>√</td><td>不存在</td><td>不存在</td><td>不满足</td></tr><tr><td>BCNF</td><td>√</td><td>不存在</td><td>不存在</td><td>满足</td></tr></tbody></table><p>例题</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>某公司数据库中的元件关系模式为P(元件号，元件名称，供应商，供应商所在地，库存量)，函数依赖集F如下所示:F={元件号一元件名称， (元件号，供应商)一库存量，供应商一供应商所在地}</span></span>
<span class="line"><span>元件关系的主键为 (B)，该关系存在冗余以及插入异常和删除异常等问题。为了解决这一间题需要将元件关系分解(C);分解后的关系模式可以达到(C)。</span></span>
<span class="line"><span>A元件号，元件名称</span></span>
<span class="line"><span>B元件号，供应商</span></span>
<span class="line"><span>C元件号，供应商所在地</span></span>
<span class="line"><span>D供应商，供应商所在地</span></span>
<span class="line"><span>A元件1 (元件号，元件名称，库存量)、元件2(供应商，供应商所在地)</span></span>
<span class="line"><span>B元件1 (元件号，元件名称)、元件2 (供应商，供应商所在地，库存量</span></span>
<span class="line"><span>C元件1 (元件号，元件名称)、元件2(元件号，供应商，库存量)、元件3(供立商，供应商所在地</span></span>
<span class="line"><span>D元件1 (元件号，元件名称)、元件2(元件号，库存量)、元件3(供应商，供应商所在地)、元件4 (供应商所在地，库存量)</span></span>
<span class="line"><span>AINF</span></span>
<span class="line"><span>B2NF</span></span>
<span class="line"><span>C3NF</span></span>
<span class="line"><span>D4NF</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="考点3-模式分解" tabindex="-1">考点3：模式分解 <a class="header-anchor" href="#考点3-模式分解" aria-label="Permalink to &quot;考点3：模式分解&quot;">​</a></h3>`,181)])])}const D=s(q,[["render",f]]);export{P as __pageData,D as default};
