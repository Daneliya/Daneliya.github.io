import{_ as i,c as l,o as e,ah as t,ay as r,az as o,aA as s,aB as n,aC as d,aD as p}from"./chunks/framework.D5cOWG0Y.js";const f=JSON.parse('{"title":"堆","description":"","frontmatter":{"title":"堆","date":"2023-11-24","tags":["JVM"],"categories":["JVM"]},"headers":[],"relativePath":"Java/JVM性能调优/JVM概念/4_堆.md","filePath":"Java/JVM性能调优/JVM概念/4_堆.md","lastUpdated":1755802517000}'),_={name:"Java/JVM性能调优/JVM概念/4_堆.md"};function m(c,a,h,g,J,V){return e(),l("div",null,[...a[0]||(a[0]=[t('<h2 id="三种jvm" tabindex="-1">三种JVM <a class="header-anchor" href="#三种jvm" aria-label="Permalink to “三种JVM”">​</a></h2><ol><li>Sun公司的HotSpot。（java -version查看）</li><li>BEA的JRockit</li><li>IBM的J9VM</li></ol><h2 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to “堆”">​</a></h2><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</p><p>类加载器读取了类文件后，一般会把什么东西放到堆中？ 类、方法、常量、变量、保存我们所有引用类型的真实对象。</p><p>堆内存中细分为三个区域：</p><ul><li>新生区（伊甸园区）Young/New</li><li>养老区 old</li><li>永久区 Perm</li></ul><p><img src="'+r+'" alt="img" loading="lazy"></p><h3 id="新生区" tabindex="-1">新生区 <a class="header-anchor" href="#新生区" aria-label="Permalink to “新生区”">​</a></h3><p>新生区又叫做伊甸园区，包括：伊甸园区、幸存0区、幸存1区。</p><h3 id="永久区" tabindex="-1">永久区 <a class="header-anchor" href="#永久区" aria-label="Permalink to “永久区”">​</a></h3><p>这个区域是<strong>常驻内存</strong>的。 用来存放JDK自身携带的Class对象、Interface元数据，存储的是Java运行时的一些环境或类信息~。 这个区域<strong>不存在垃圾回收</strong>。 关闭JVM虚拟机就会释放这个区域的内存。</p><p>什么情况下，在永久区就崩了？</p><ul><li>一个启动类，加载了大量的第三方jar包。</li><li>Tomcat部署了太多的应用。</li><li>大量动态生成的反射类；不断的被加载，直到内存满，就会出现OOM</li></ul><h3 id="永久代和元空间" tabindex="-1">永久代和元空间 <a class="header-anchor" href="#永久代和元空间" aria-label="Permalink to “永久代和元空间”">​</a></h3><p>什么是永久代和元空间？？ 方法区是一种规范，不同的虚拟机厂商可以基于规范做出不同的实现，永久代和元空间就是出于不同jdk版本的实现。 方法区就像是一个接口，永久代与元空间分别是两个不同的实现类。 只不过永久代是这个接口最初的实现类，后来这个接口一直进行变更，直到最后彻底废弃这个实现类，由新实现类—元空间进行替代。</p><p>jdk1.8之前： <img src="'+o+'" alt="img" loading="lazy"></p><p>jdk1.8以及之后：在堆内存中，逻辑上存在，物理上不存在（元空间使用的是本地内存） <img src="'+s+'" alt="img" loading="lazy"></p><h3 id="常量池" tabindex="-1">常量池 <a class="header-anchor" href="#常量池" aria-label="Permalink to “常量池”">​</a></h3><ol><li>在jdk1.7之前，运行时常量池+字符串常量池是存放在方法区中，HotSpot VM对方法区的实现称为永久代。 <img src="'+n+'" alt="img" loading="lazy"></li><li>在jdk1.7中，字符串常量池从方法区移到堆中，运行时常量池保留在方法区中。 <img src="'+d+'" alt="img" loading="lazy"></li><li>jdk1.8之后，HotSpot移除永久代，使用元空间代替；此时字符串常量池保留在堆中，运行时常量池保留在方法区中，只是实现不一样了，JVM内存变成了直接内存。 <img src="'+p+'" alt="img" loading="lazy"></li></ol>',20)])])}const k=i(_,[["render",m]]);export{f as __pageData,k as default};
