import{_ as t,c as e,o as i,aN as l}from"./chunks/framework.CMIDsdwV.js";const o="/assets/kuangstudycbc2c908-bf86-4263-9848-a63bfaa11fd7.9OFtfOnD.jpg",s="/assets/kuangstudy590e2fb9-b6fe-465c-b9fe-c6281130c20d.hAx2L-qF.jpg",r="/assets/kuangstudy39072ea5-d640-4d2c-b80a-925e0780a0fc.DJKSU6F8.jpg",d="/assets/kuangstudyfa4dab7f-9a26-4298-b00c-a4b2d4afff7e.CuEhqo85.jpg",n="/assets/kuangstudyfb7f3f21-0aec-4be9-b4ed-db5c61754645.CDMyqi2U.jpg",c="/assets/kuangstudydcc630f0-4406-4a14-9275-af78afa6ca73.BLwg8sts.jpg",J=JSON.parse('{"title":"堆","description":"","frontmatter":{"title":"堆","date":"2023-11-24","permalink":"/java/jvm/heap","tags":["JVM"],"categories":["JVM"]},"headers":[],"relativePath":"Java/JVM性能调优/01.JVM概念/4_堆.md","filePath":"Java/JVM性能调优/01.JVM概念/4_堆.md","lastUpdated":1767444225000}'),p={name:"Java/JVM性能调优/01.JVM概念/4_堆.md"};function m(h,a,u,g,_,f){return i(),e("div",null,[...a[0]||(a[0]=[l('<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /Java\\JVM性能调优\\01.JVM概念\\4_堆.md for this page in Markdown format</div><h1 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h1><h2 id="三种jvm" tabindex="-1">三种JVM <a class="header-anchor" href="#三种jvm" aria-label="Permalink to &quot;三种JVM&quot;">​</a></h2><ol><li>Sun公司的HotSpot。（java -version查看）</li><li>BEA的JRockit</li><li>IBM的J9VM</li></ol><h2 id="堆-1" tabindex="-1">堆 <a class="header-anchor" href="#堆-1" aria-label="Permalink to &quot;堆&quot;">​</a></h2><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</p><p>类加载器读取了类文件后，一般会把什么东西放到堆中？ 类、方法、常量、变量、保存我们所有引用类型的真实对象。</p><p>堆内存中细分为三个区域：</p><ul><li>新生区（伊甸园区）Young/New</li><li>养老区 old</li><li>永久区 Perm</li></ul><p><img src="'+o+'" alt="img" loading="lazy"></p><h3 id="新生区" tabindex="-1">新生区 <a class="header-anchor" href="#新生区" aria-label="Permalink to &quot;新生区&quot;">​</a></h3><p>新生区又叫做伊甸园区，包括：伊甸园区、幸存0区、幸存1区。</p><h3 id="永久区" tabindex="-1">永久区 <a class="header-anchor" href="#永久区" aria-label="Permalink to &quot;永久区&quot;">​</a></h3><p>这个区域是<strong>常驻内存</strong>的。 用来存放JDK自身携带的Class对象、Interface元数据，存储的是Java运行时的一些环境或类信息~。 这个区域<strong>不存在垃圾回收</strong>。 关闭JVM虚拟机就会释放这个区域的内存。</p><p>什么情况下，在永久区就崩了？</p><ul><li>一个启动类，加载了大量的第三方jar包。</li><li>Tomcat部署了太多的应用。</li><li>大量动态生成的反射类；不断的被加载，直到内存满，就会出现OOM</li></ul><h3 id="永久代和元空间" tabindex="-1">永久代和元空间 <a class="header-anchor" href="#永久代和元空间" aria-label="Permalink to &quot;永久代和元空间&quot;">​</a></h3><p>什么是永久代和元空间？？ 方法区是一种规范，不同的虚拟机厂商可以基于规范做出不同的实现，永久代和元空间就是出于不同jdk版本的实现。 方法区就像是一个接口，永久代与元空间分别是两个不同的实现类。 只不过永久代是这个接口最初的实现类，后来这个接口一直进行变更，直到最后彻底废弃这个实现类，由新实现类—元空间进行替代。</p><p>jdk1.8之前： <img src="'+s+'" alt="img" loading="lazy"></p><p>jdk1.8以及之后：在堆内存中，逻辑上存在，物理上不存在（元空间使用的是本地内存） <img src="'+r+'" alt="img" loading="lazy"></p><h3 id="常量池" tabindex="-1">常量池 <a class="header-anchor" href="#常量池" aria-label="Permalink to &quot;常量池&quot;">​</a></h3><ol><li>在jdk1.7之前，运行时常量池+字符串常量池是存放在方法区中，HotSpot VM对方法区的实现称为永久代。 <img src="'+d+'" alt="img" loading="lazy"></li><li>在jdk1.7中，字符串常量池从方法区移到堆中，运行时常量池保留在方法区中。 <img src="'+n+'" alt="img" loading="lazy"></li><li>jdk1.8之后，HotSpot移除永久代，使用元空间代替；此时字符串常量池保留在堆中，运行时常量池保留在方法区中，只是实现不一样了，JVM内存变成了直接内存。 <img src="'+c+'" alt="img" loading="lazy"></li></ol>',22)])])}const k=t(p,[["render",m]]);export{J as __pageData,k as default};
