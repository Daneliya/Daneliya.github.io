import{_ as e,c as i,o as t,aN as o}from"./chunks/framework.CMIDsdwV.js";const c=JSON.parse('{"title":"系统优化之限流","description":"","frontmatter":{"title":"系统优化之限流","tags":["日常笔记"],"categories":["日常笔记"]},"headers":[],"relativePath":"Java/架构设计/高可用/限流/系统优化之限流.md","filePath":"Java/架构设计/高可用/限流/系统优化之限流.md","lastUpdated":1767444225000}'),r={name:"Java/架构设计/高可用/限流/系统优化之限流.md"};function n(l,a,p,s,m,d){return t(),i("div",null,[...a[0]||(a[0]=[o('<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /Java\\架构设计\\高可用\\限流\\系统优化之限流.md for this page in Markdown format</div><h1 id="系统优化之限流" tabindex="-1">系统优化之限流 <a class="header-anchor" href="#系统优化之限流" aria-label="Permalink to &quot;系统优化之限流&quot;">​</a></h1><p>我们需要控制用户使用系统的次数，以避免超支，比如给不同等级的用户分配不同的调用次数，防止用户过度使用系统造成破产(例如给普通用户提供 50 次调用次数，会员用户提供 100 次)。但限制用户调用次数仍存在一定风险，用户仍有可能通过疯狂调用来刷量，从而导致系统成本过度消耗。 假设系统就一台服务器，能同时处理的用户对话数量是有限的，比如系统最多只能支持 10 个用户同时对话，如果某个用户一秒内使用 10 个账号登录，那么其他用户就无法使用系统。就像去自助餐厅吃饭，如果有人一股脑地把所有美食都拿光了，其他人就无法享用了。比如双 11 这种大促期间，阿里巴巴就要去限制，不能说所有的用户想抢购都能成功，在前端随机放行一部分用户，而对于其他用户则进行限制，以确保系统不会被恶意用户占满。现在要做一个解决方案，就是限流，比如说限制单个用户在每秒只能使用一次，那这里我们怎么去思考这个限流的阈值是多少？多少合适呢？</p><p>**问题：**使用系统是需要消耗成本的，用户有可能疯狂刷量，让你破产。 <strong>解决方案：</strong></p><ol><li>控制成本 =&gt; 限制用户调用总次数</li><li>用户在短时间内疯狂使用，导致服务器资源被占满，其他用户无法使用 =&gt; 限流</li></ol><p><strong>思考：</strong> 限流阈值多大合适？参考正常用户的使用，比如限制单个用户在每秒只能使用 1 次。</p><h2 id="限流的算法" tabindex="-1">限流的算法 <a class="header-anchor" href="#限流的算法" aria-label="Permalink to &quot;限流的算法&quot;">​</a></h2><p>建议 <a href="https://juejin.cn/post/6967742960540581918" target="_blank" rel="noreferrer">阅读文章</a>。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25430380/1685601301044-b47fba22-69b5-45d0-89fd-7bff7096b665.png?x-oss-process=image%2Fresize%2Cw_668%2Climit_0#averageHue=%23e8f7e2&amp;from=url&amp;id=rDCvT&amp;originHeight=703&amp;originWidth=668&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"></p><p><strong>食堂排队举例：</strong></p><ol><li>规定窗口限流 你去食堂买汉堡，食堂每一小时只允许 10 个用户买汉堡，汉堡一小时只能做 10 个，第 59 分钟来了 10 个人，第 60 分钟又来 10 个人，汉堡就不够了。</li><li>滑动窗口限流 每 10 分钟食堂做一个汉堡，这样的话，假如前一个小时汉堡已经被抢光了，然后 1 小时 10 分钟来的一个新用户，他又能抢到 1 小时 10 分钟得到的那个汉堡。</li><li>漏桶限流 大家排好队，一个一个去拿汉堡，前面一个人拿完，后面一个人才能拿。</li><li>令牌桶限流 食堂事先做好 10 个汉堡，假如现在开抢了，前 10 个人能够同时拿到汉堡，不用排队，但剩下的 10 个人就只能等下一批汉堡做好才能拿。</li></ol><h2 id="限流粒度" tabindex="-1">限流粒度 <a class="header-anchor" href="#限流粒度" aria-label="Permalink to &quot;限流粒度&quot;">​</a></h2><ol><li>针对某个方法限流，即单位时间内最多允许同时 XX 个操作使用这个方法</li><li>针对某个用户限流，比如单个用户单位时间内最多执行 XX 次操作</li><li>针对某个用户 x 方法限流，比如单个用户单位时间内最多执行 XX 次这个方法</li></ol><h2 id="限流实现构思" tabindex="-1">限流实现构思 <a class="header-anchor" href="#限流实现构思" aria-label="Permalink to &quot;限流实现构思&quot;">​</a></h2><h3 id="_1-本地限流-单机限流" tabindex="-1">1）本地限流(单机限流) <a class="header-anchor" href="#_1-本地限流-单机限流" aria-label="Permalink to &quot;1）本地限流(单机限流)&quot;">​</a></h3><p>每个服务器单独限流，一般适用于单体项目，就是你的**项目只有一个服务器 **。 🪔 举个例子，假设你的系统有三台服务器，每台服务器限制用户每秒只能请求一次。你可以为每台服务器单独设置限流策略，这样每个服务器都能够独立地控制用户的请求频率。但是这种限流方式并不是很可靠，因为你并不知道用户的请求会落在哪台服务器上，它的分布是有一定的偶然性的。即使你采用负载均衡技术，让用户请求轮流发送到每台服务器，仍然存在一定的风险。 在 Java 中，有很多第三方库可以用来实现单机限流：Guava RateLimiter：这是谷歌 Guava 库提供的限流工具，可以对单位时间内的请求数量进行限制。</p><h3 id="_2-分布式限流-多机限流" tabindex="-1">2）分布式限流(多机限流) <a class="header-anchor" href="#_2-分布式限流-多机限流" aria-label="Permalink to &quot;2）分布式限流(多机限流)&quot;">​</a></h3><p>如果项目有多个服务器，比如微服务，那么建议使用分布式限流。</p><ol><li>把用户的使用频率等数据放到一个集中的存储进行统计； 比如 Redis，这样无论用户的请求落到了哪台服务器，都以集中存储中的数据为准。 (Redisson -- 是一个操作 Redis 的工具库 , 伙伴匹配系统讲过)</li><li>在网关集中进行限流和统计（比如 Sentinel、Spring Cloud Gateway）</li></ol><h2 id="redisson-限流实现" tabindex="-1">Redisson 限流实现 <a class="header-anchor" href="#redisson-限流实现" aria-label="Permalink to &quot;Redisson 限流实现&quot;">​</a></h2><p>Redisson 内置了一个限流工具类，可以帮助你利用 Redis 来存储、来统计。 根据官方文档提示，先引入依赖。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25430380/1685438575065-6486eda8-fed0-4f63-96cd-421b03d8a63a.png?x-oss-process=image%2Fresize%2Cw_448%2Climit_0#averageHue=%23ebce9b&amp;from=url&amp;id=tWoN1&amp;originHeight=528&amp;originWidth=448&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 粘贴至pom.xml。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25430380/1685601583818-c9e31d13-322e-4edb-ab77-fc5994219192.png?x-oss-process=image%2Fresize%2Cw_663%2Climit_0#averageHue=%23f8f5f4&amp;from=url&amp;id=p6uLL&amp;originHeight=456&amp;originWidth=663&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"></p><p>创建 RedissonConfig 配置类，用于初始化 RedissonClient 对象单例； 在config目录下新建RedissonConfig.java。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25430380/1685442029087-d5db1c45-4d0e-4cdc-b28c-4f7264863278.png?x-oss-process=image%2Fresize%2Cw_655%2Climit_0#averageHue=%23f9f7f5&amp;from=url&amp;id=XNoGk&amp;originHeight=393&amp;originWidth=655&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"> 编写配置。 去application.yml取消 redis 配置注释。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/25430380/1685601731550-9ab95268-afcd-48cd-a7cc-358ee0ca1b8a.png?x-oss-process=image%2Fresize%2Cw_642%2Climit_0#averageHue=%23f7f5f4&amp;from=url&amp;id=RjUzR&amp;originHeight=404&amp;originWidth=642&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt="" loading="lazy"></p>',26)])])}const h=e(r,[["render",n]]);export{c as __pageData,h as default};
