import{_ as e,c as t,o as i,aN as l}from"./chunks/framework.CMIDsdwV.js";const r="/assets/kuangstudyea734fba-0acf-411a-9145-b09bf0f8c0fa.D3v2Enlg.jpg",o="/assets/kuangstudyba7e21f0-b594-4d03-a045-f0bc7999d1b9.TXZtGFyU.jpg",s="/assets/kuangstudyfcf0c24d-0c57-444f-a3e7-75bf360afaa6.Bt345Vew.jpg",d="/assets/kuangstudye7037e48-3068-4698-beea-ab5bd6c93f89.r2G0lF_p.jpg",n="/assets/kuangstudy917c317f-d10a-4a63-adcc-1d9f569ca63e.C-X93vOr.jpg",c="/assets/kuangstudy47e8d6fc-3f99-4296-b75e-608518e1403f.DPYPruTy.jpg",C=JSON.parse('{"title":"GC垃圾回收","description":"","frontmatter":{"title":"GC垃圾回收","date":"2023-11-25","permalink":"/java/jvm/gc","tags":["JVM"],"categories":["JVM"]},"headers":[],"relativePath":"Java/JVM性能调优/01.JVM概念/5_GC垃圾回收.md","filePath":"Java/JVM性能调优/01.JVM概念/5_GC垃圾回收.md","lastUpdated":1767444225000}'),h={name:"Java/JVM性能调优/01.JVM概念/5_GC垃圾回收.md"};function p(u,a,g,_,m,f){return i(),t("div",null,[...a[0]||(a[0]=[l('<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /Java\\JVM性能调优\\01.JVM概念\\5_GC垃圾回收.md for this page in Markdown format</div><h1 id="gc垃圾回收" tabindex="-1">GC垃圾回收 <a class="header-anchor" href="#gc垃圾回收" aria-label="Permalink to &quot;GC垃圾回收&quot;">​</a></h1><h2 id="垃圾回收的区域" tabindex="-1">垃圾回收的区域 <a class="header-anchor" href="#垃圾回收的区域" aria-label="Permalink to &quot;垃圾回收的区域&quot;">​</a></h2><p><img src="'+r+'" alt="img" loading="lazy"></p><h2 id="gc之引用计数法" tabindex="-1">GC之引用计数法 <a class="header-anchor" href="#gc之引用计数法" aria-label="Permalink to &quot;GC之引用计数法&quot;">​</a></h2><p><img src="'+o+'" alt="img" loading="lazy"></p><h2 id="gc之复制算法" tabindex="-1">GC之复制算法 <a class="header-anchor" href="#gc之复制算法" aria-label="Permalink to &quot;GC之复制算法&quot;">​</a></h2><p><img src="'+s+'" alt="img" loading="lazy"><img src="'+d+'" alt="img" loading="lazy"></p><ul><li>好处：没有内存的碎片。</li><li>坏处：浪费了内存空间（多了一半空间to永远是空）。假设对象100%存活（极端情况），不适合使用复制算法。</li></ul><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p>复制算法最佳使用场景：对象存活度较低的时候（新生区）</p><h2 id="gc之标记清除压缩算法" tabindex="-1">GC之标记清除压缩算法 <a class="header-anchor" href="#gc之标记清除压缩算法" aria-label="Permalink to &quot;GC之标记清除压缩算法&quot;">​</a></h2><h3 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h3><p><img src="'+n+'" alt="img" loading="lazy"></p><ul><li>优点：不需要额外的空间。</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片。</li></ul><h3 id="标记清除压缩" tabindex="-1">标记清除压缩 <a class="header-anchor" href="#标记清除压缩" aria-label="Permalink to &quot;标记清除压缩&quot;">​</a></h3><p><img src="'+c+'" alt="img" loading="lazy"></p><h3 id="标记清除压缩-改进" tabindex="-1">标记清除压缩（改进） <a class="header-anchor" href="#标记清除压缩-改进" aria-label="Permalink to &quot;标记清除压缩（改进）&quot;">​</a></h3><p>可以进行多次标记清除，再进行一次压缩。</p><h2 id="gc算法总结" tabindex="-1">GC算法总结 <a class="header-anchor" href="#gc算法总结" aria-label="Permalink to &quot;GC算法总结&quot;">​</a></h2><p>内存效率：复制算法&gt;标记清除算法&gt;标记压缩算法（时间复杂度） 内存整齐度：复制算法=标记压缩算法&gt;标记清除算法 内存利用率：标记压缩算法=标记清除算法&gt;复制算法</p><p>思考一个问题：难道没有最优算法吗？ 答案：没有，没有最好的算法，只有最合适的算法——》GC：分代收集算法</p><p>年轻代：</p><ul><li>存活率低</li><li>复制算法</li></ul><p>老年代：</p><ul><li>区域大：存活率高</li><li>标记清除（内存碎片不是太多）+标记压缩混合实现</li></ul>',26)])])}const k=e(h,[["render",p]]);export{C as __pageData,k as default};
