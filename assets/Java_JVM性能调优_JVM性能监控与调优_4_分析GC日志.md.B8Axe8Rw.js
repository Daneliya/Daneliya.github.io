import{_ as a,c as s,o as e,ah as l,ak as t}from"./chunks/framework.D5cOWG0Y.js";const c=JSON.parse('{"title":"分析GC日志","description":"","frontmatter":{"title":"分析GC日志","tags":["JVM"],"categories":["JVM"]},"headers":[],"relativePath":"Java/JVM性能调优/JVM性能监控与调优/4_分析GC日志.md","filePath":"Java/JVM性能调优/JVM性能监控与调优/4_分析GC日志.md","lastUpdated":1755802517000}'),h={name:"Java/JVM性能调优/JVM性能监控与调优/4_分析GC日志.md"};function r(n,i,k,p,g,d){return e(),s("div",null,[...i[0]||(i[0]=[l('<h2 id="分析gc日志" tabindex="-1">分析GC日志 <a class="header-anchor" href="#分析gc日志" aria-label="Permalink to “分析GC日志”">​</a></h2><h3 id="gc分类" tabindex="-1">GC分类 <a class="header-anchor" href="#gc分类" aria-label="Permalink to “GC分类”">​</a></h3><p><img src="'+t+`" alt="在这里插入图片描述" loading="lazy"></p><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li>部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集。其中又分为： <ul><li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为。</li></ul></li><li>整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。</li></ul><h3 id="gc日志分类" tabindex="-1">GC日志分类 <a class="header-anchor" href="#gc日志分类" aria-label="Permalink to “GC日志分类”">​</a></h3><h4 id="minorgc" tabindex="-1">MinorGC <a class="header-anchor" href="#minorgc" aria-label="Permalink to “MinorGC”">​</a></h4><p>MinorGC（或young GC或YGC）日志：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[GC (Allocation Failure) [PSYoungGen: 31744K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">2192K (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36864</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K) ] 31744K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">2200K (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">121856</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0139308</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secs] [Times: user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sys</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">0.01, real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secs]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># [GC (Allocation Failure) [新生代: Young GC 前新生代内存占用-&gt;Young GC 后新生代内存占用 (新生代总大小) ] Young GC 前 JVM 堆内存占用-&gt;Young GC 后 JVM 堆内存使用 (JVM 堆总大小), Young GC 耗时] [Times: user=Young GC 用户耗时 sys=Young GC 系统耗时, real=Young GC 实际耗时]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="fullgc" tabindex="-1">FullGC <a class="header-anchor" href="#fullgc" aria-label="Permalink to “FullGC”">​</a></h4><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[Full GC (Metadata GC Threshold) [PSYoungGen: 5104K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">0K (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">132096</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K) ] [Par01dGen: 416K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">5453K (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50176</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K) ]5520K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">5453K (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">182272</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K), [Metaspace: 20637K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">20637K (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1067008</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K) ], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0245883</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secs] [Times: user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.06</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sys</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">0.00, real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.02</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secs]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># [Full GC (Metadata GC Threshold) [新生代: GC 前新生代内存占用-&gt;GC 后新生代内存占用 (新生代总大小) ] [老年代: GC 前老年代内存占用-&gt;GC 后老年代内存占用 (老年代总大小) ]GC 前堆内存占用-&gt;GC 后堆内存占用 (JVM 堆总大小), [元空间:  GC 前元空间内存占用-&gt;GC 后元空间内存占用 (元空间总大小) ], GC 耗时] [Times: user=GC 用户耗时 sys=GC 系统耗时 , real=GC 实际耗时]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="gc日志结构剖析" tabindex="-1">GC日志结构剖析 <a class="header-anchor" href="#gc日志结构剖析" aria-label="Permalink to “GC日志结构剖析”">​</a></h3><h4 id="垃圾收集器" tabindex="-1"><strong>垃圾收集器</strong> <a class="header-anchor" href="#垃圾收集器" aria-label="Permalink to “垃圾收集器”">​</a></h4><ul><li>Serial收集器：新生代显示 &quot;[DefNew&quot;，即 Default New Generation</li><li>ParNew收集器：新生代显示 &quot;[ParNew&quot;，即 Parallel New Generation</li><li>Parallel Scavenge收集器：新生代显示&quot;[PSYoungGen&quot;，JDK1.7使用的即PSYoungGen</li><li>Parallel Old收集器：老年代显示&quot;[ParoldGen&quot;</li><li>G1收集器：显示”garbage-first heap“</li></ul><h4 id="gc原因" tabindex="-1"><strong>GC原因</strong> <a class="header-anchor" href="#gc原因" aria-label="Permalink to “GC原因”">​</a></h4><ul><li>Allocation Failure：表明本次引起GC的原因是因为新生代中没有足够的区域存放需要分配的数据</li><li>Metadata GCThreshold：Metaspace区不够用了</li><li>FErgonomics：JVM自适应调整导致的GC</li><li>System：调用了System.gc()方法</li></ul><h4 id="gc日志格式规律" tabindex="-1"><strong>GC日志格式规律</strong> <a class="header-anchor" href="#gc日志格式规律" aria-label="Permalink to “GC日志格式规律”">​</a></h4><p>GC日志格式的规律一般都是：GC前内存占用-＞GC后内存占用（该区域内存总大小）</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[PSYoungGen: 5986K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">696K (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8704</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">K) ] 5986K-</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">704K (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">9216K</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>中括号内：GC回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul><p>注意：Minor GC堆内存总容量 = 9/10 年轻代 + 老年代。原因是Survivor区只计算from部分，而JVM默认年轻代中Eden区和Survivor区的比例关系，Eden:S0:S1=8:1:1。</p><h4 id="gc时间" tabindex="-1"><strong>GC时间</strong> <a class="header-anchor" href="#gc时间" aria-label="Permalink to “GC时间”">​</a></h4><p>GC日志中有三个时间：user，sys和real</p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示GC线程执行所使用的 CPU 总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的CPU 时间</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的GC事件中，real time是小于sys time＋user time的，因为一般是多个线程并发的去做GC，所以real time是要小于sys＋user time的。如果real＞sys＋user的话，则你的应用可能存在下列问题：IO负载非常重或CPU不够用。</p><h3 id="gc日志分析工具" tabindex="-1">GC日志分析工具 <a class="header-anchor" href="#gc日志分析工具" aria-label="Permalink to “GC日志分析工具”">​</a></h3><h4 id="gceasy" tabindex="-1">GCEasy <a class="header-anchor" href="#gceasy" aria-label="Permalink to “GCEasy”">​</a></h4><p>GCEasy是一款在线的GC日志分析器，可以通过GC日志分析进行内存泄露检测、GC暂停原因分析、JVM配置建议优化等功能，大多数功能是免费的。</p><p>官网地址：<a href="https://gceasy.io/" target="_blank" rel="noreferrer">https://gceasy.io/</a></p><h4 id="gcviewer" tabindex="-1">GCViewer <a class="header-anchor" href="#gcviewer" aria-label="Permalink to “GCViewer”">​</a></h4><p>GCViewer是一款离线的GC日志分析器，用于可视化Java VM选项 -verbose:gc 和 .NET生成的数据 -Xloggc:、、&lt;file&gt;。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p><p>源码下载：<a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noreferrer">https://github.com/chewiebug/GCViewer</a></p><p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog" target="_blank" rel="noreferrer">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p><h4 id="gchisto" tabindex="-1">GChisto <a class="header-anchor" href="#gchisto" aria-label="Permalink to “GChisto”">​</a></h4><ul><li>官网上没有下载的地方，需要自己从SVN上拉下来编译</li><li>不过这个工具似乎没怎么维护了，存在不少bug</li></ul><h4 id="hpjmeter" tabindex="-1">HPjmeter <a class="header-anchor" href="#hpjmeter" aria-label="Permalink to “HPjmeter”">​</a></h4><ul><li>工具很强大，但是只能打开由以下参数生成的GC log，-verbose:gc -Xloggc:gc.log。添加其他参数生成的gc.log无法打开</li><li>HPjmeter集成了以前的HPjtune功能，可以分析在HP机器上产生的垃圾回收日志文件</li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to “参考资料”">​</a></h2><p><a href="https://blog.csdn.net/qq_43468008/article/details/129774175" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_43468008/article/details/129774175</a></p><p><a href="https://www.yuque.com/u21195183/jvm/ukmb3k" target="_blank" rel="noreferrer">https://www.yuque.com/u21195183/jvm/ukmb3k</a></p><p><a href="https://juejin.cn/post/6844903669251440653" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903669251440653</a></p>`,41)])])}const C=a(h,[["render",r]]);export{c as __pageData,C as default};
